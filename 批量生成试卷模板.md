# 林业经济学（双语）试卷批量生成模板

## 1. 题目库结构

### 1.1 单选题库
```json
{
  "single_choice_questions": [
    {
      "id": "sc_001",
      "type": "concept",
      "difficulty": "easy",
      "chinese_stem": "Merit goods在林业经济学中指的是什么？（）",
      "english_stem": "What does \"Merit goods\" refer to in forest economics? ()",
      "options": {
        "A": "社会价值低于私人消费者价值的商品",
        "A_en": "Merchandise with social value lower than private consumer value",
        "B": "社会价值超过私人消费者价值的商品", 
        "B_en": "Merchandise with social value exceeding private consumer value",
        "C": "仅具有私人价值的商品",
        "C_en": "Merchandise with private value only",
        "D": "仅具有社会价值的商品",
        "D_en": "Merchandise with social value only"
      },
      "correct_answer": "B",
      "knowledge_point": "Merit goods definition",
      "tags": ["basic", "definition", "public goods"]
    },
    {
      "id": "sc_002", 
      "type": "concept",
      "difficulty": "medium",
      "chinese_stem": "以下哪一个选项可能导致“technological externality”？（）",
      "english_stem": "Which of the following could lead to \"technological externality\"? ()",
      "options": {
        "A": "产生外部效益或成本的生产者与承担结果的人之间没有通过市场建立联系。",
        "A_en": "Producers generating external benefits or costs are not linked to those bearing the consequences through market mechanisms.",
        "B": "可以被消费而不会减少其对他人可用性的利益。", 
        "B_en": "Benefits that can be consumed without diminishing their availability to others.",
        "C": "竞争障碍，如自然垄断、寡头垄断和进入壁垒。",
        "C_en": "Barriers to competition, such as natural monopolies, oligopolies, and entry barriers.",
        "D": "一个企业通过其投入品或产品市场对另一个企业产生的有利或不利影响。",
        "D_en": "Favorable or unfavorable effects one firm exerts on another through input or product markets."
      },
      "correct_answer": "D",
      "knowledge_point": "Technological externality",
      "tags": ["externality", "market", "impact"]
    }
  ]
}
```

### 1.2 是非题库
```json
{
  "true_false_questions": [
    {
      "id": "tf_001",
      "chinese_stem": "\"Contingent valuation method\"是一种了解消费者偏好的显示型（Revealed preference)方法。",
      "english_stem": "The Contingent Valuation Method (CVM) is a revealed preference approach for eliciting consumer preferences.",
      "correct_answer": "F",
      "explanation": "CVM是陈述型（Stated preference）方法，而非显示型（Revealed preference）方法。",
      "explanation_en": "CVM is a stated preference approach, not a revealed preference approach.",
      "knowledge_point": "CVM methodology",
      "tags": ["valuation", "method", "preference"]
    }
  ]
}
```

### 1.3 论述题库
```json
{
  "essay_questions": [
    {
      "id": "es_001",
      "chinese_stem": "有哪些不同类型的"外部性"？请列举出至少三种，并举例分析每种外部性分别是如何产生的？有何应对措施？",
      "english_stem": "What are the different types of externalities? Please identify at least three distinct categories and provide illustrative examples demonstrating how each type of externality arises. What policy interventions or remedial measures can be implemented to address them?",
      "scoring_guide": [
        "识别三种以上外部性类型 (5分)",
        "每种类型提供具体例子 (5分)", 
        "分析产生机制 (3分)",
        "提出应对措施 (2分)"
      ],
      "scoring_guide_en": [
        "Identify three or more types of externalities (5 points)",
        "Provide specific examples for each type (5 points)",
        "Analyze generation mechanisms (3 points)",
        "Propose countermeasures (2 points)"
      ],
      "knowledge_point": "Types of externalities",
      "tags": ["externality", "classification", "policy"]
    }
  ]
}
```

### 1.4 计算题库
```json
{
  "calculation_questions": [
    {
      "id": "calc_001",
      "context": {
        "chinese": "某村庄有一片荒地，如果自然更新，每30年可以产出价值10.9万元的木材，采伐成本为1万元。村委会现在要从以下投资决策中做出选择：",
        "english": "A village possesses a tract of wasteland. Under natural regeneration, it would yield timber valued at ¥109,000 every 30 years, with harvesting costs of ¥10,000. The village committee must now choose among the following investment alternatives:"
      },
      "alternatives": [
        {
          "type": "afforestation",
          "description": {
            "chinese": "投资20万元种植松树，每20年产出木材价值70万元的木材，采伐成本为6万元，每年的管理成本为1000元。",
            "english": "Invest ¥200,000 to establish a pine plantation, generating timber valued at ¥700,000 every 20 years, with harvesting costs of ¥60,000 and annual management costs of ¥1,000."
          }
        },
        {
          "type": "leasing",
          "description": {
            "chinese": "将荒地直接承包给外来经营者，对方承诺经过5年投产期后，每年向村集体交付1万元租金",
            "english": "Lease the wasteland directly to an external operator, who commits to paying annual rent of ¥10,000 to the village collective after a 5-year establishment period."
          }
        },
        {
          "type": "eco_tourism", 
          "description": {
            "chinese": "投资170万元，将荒地改造为生态旅游景区，1年后开始获得稳定回报，预期每年能带来10万元净回报",
            "english": "Invest ¥1,700,000 to transform the wasteland into an eco-tourism destination, which would begin generating stable returns after one year, with anticipated annual net returns of ¥100,000."
          }
        }
      ],
      "parameters": {
        "discount_rate": 0.05,
        "time_periods": {"5_year": 1.3, "10_year": 1.6, "20_year": 2.6, "30_year": 4.3},
        "formula": "F=A*[(1+i)^n-1]/i"
      },
      "requirements": [
        "chinese": "请计算不同投资决策的净现值，并根据净现值考虑选择哪种投资决策？",
        "english": "Calculate the net present value (NPV) of each investment alternative and determine which option should be selected based on NPV analysis."
      ],
      "additional_requirements": [
        "chinese": "假如你是村委会的决策人，在投资决策时，除了净现值以外，你还将考虑哪些因素？分析在考虑这些因素后，你会如何改变决策？",
        "english": "If you were the decision-maker for the village committee, what additional factors beyond NPV would you consider in the investment decision? Analyze how consideration of these factors might alter your decision."
      ],
      "knowledge_point": "NPV calculation",
      "tags": ["NPV", "investment", "decision"]
    }
  ]
}
```

## 2. 试卷生成器代码模板

### 2.1 Python生成器
```python
import json
import random
from datetime import datetime

class ForestEconomicsExamGenerator:
    def __init__(self, question_database_path):
        self.question_database = self.load_question_database(question_database_path)
    
    def load_question_database(self, path):
        """加载题目数据库"""
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def generate_exam(self, exam_config):
        """
        生成试卷
        :param exam_config: 试卷配置参数
        :return: 生成的试卷内容
        """
        exam_content = {
            'header': self.generate_header(exam_config),
            'score_table': self.generate_score_table(exam_config),
            'questions': []
        }
        
        # 生成各类型题目
        if 'single_choice' in exam_config['question_types']:
            single_choice = self.generate_single_choice_questions(
                exam_config['question_types']['single_choice']
            )
            exam_content['questions'].extend(single_choice)
        
        if 'true_false' in exam_config['question_types']:
            true_false = self.generate_true_false_questions(
                exam_config['question_types']['true_false']
            )
            exam_content['questions'].extend(true_false)
        
        if 'essay' in exam_config['question_types']:
            essay = self.generate_essay_questions(
                exam_config['question_types']['essay']
            )
            exam_content['questions'].extend(essay)
        
        if 'calculation' in exam_config['question_types']:
            calculation = self.generate_calculation_questions(
                exam_config['question_types']['calculation']
            )
            exam_content['questions'].extend(calculation)
        
        return exam_content
    
    def generate_header(self, config):
        """生成试卷头部信息"""
        return f"""
{config['school']}{config['academic_year']}期末考试试卷
课程名称：《{config['course_name']}（双语）》 （{config['paper_type']}）卷
课程代号：{config['course_code']}
考试形式：{config['exam_type']}
使用对象：
        """.strip()
    
    def generate_score_table(self, config):
        """生成题型分值表"""
        question_types = config['question_types']
        total_score = sum([q['count'] * q['score_per_question'] for q in question_types.values()])
        
        header = "题号"
        scores = "分值"
        points = "得分"
        
        for i, (q_type, q_config) in enumerate(question_types.items()):
            header += f"\t{chr(97+i)}\t"  # a, b, c...
            scores += f"\t{q_config['count'] * q_config['score_per_question']}\t"
            points += f"\t\t"
        
        header += "总分\t总分人"
        scores += f"\t{total_score}\t"
        points += "\t\t"
        
        return {
            'header': header,
            'scores': scores,
            'points': points
        }
    
    def generate_single_choice_questions(self, config):
        """生成单选题"""
        # 从题库中随机选择指定数量的题目
        available_questions = [
            q for q in self.question_database['single_choice_questions']
            if q['difficulty'] == config.get('difficulty', 'medium')
        ]
        
        selected_questions = random.sample(available_questions, config['count'])
        
        questions = []
        for i, q in enumerate(selected_questions, 1):
            question_text = f"""
{i}. {q['chinese_stem']}

A. {q['options']['A']}
B. {q['options']['B']}  
C. {q['options']['C']}
D. {q['options']['D']}

{i}. {q['english_stem']}

A. {q['options']['A_en']}
B. {q['options']['B_en']}
C. {q['options']['C_en']}
D. {q['options']['D_en']}
            """.strip()
            
            questions.append({
                'type': 'single_choice',
                'number': i,
                'content': question_text,
                'correct_answer': q['correct_answer']
            })
        
        return questions
    
    def generate_true_false_questions(self, config):
        """生成是非题"""
        available_questions = self.question_database['true_false_questions']
        selected_questions = random.sample(available_questions, config['count'])
        
        questions = []
        for i, q in enumerate(selected_questions, 1):
            question_text = f"""
{q['chinese_stem']}

{q['english_stem']}
            """.strip()
            
            questions.append({
                'type': 'true_false',
                'number': i,
                'content': question_text,
                'correct_answer': q['correct_answer']
            })
        
        return questions
    
    def generate_essay_questions(self, config):
        """生成论述题"""
        available_questions = self.question_database['essay_questions']
        selected_questions = random.sample(available_questions, config['count'])
        
        questions = []
        for i, q in enumerate(selected_questions, 1):
            question_text = f"""
{i}. {q['chinese_stem']}

{i}. {q['english_stem']}
            """.strip()
            
            questions.append({
                'type': 'essay',
                'number': i,
                'content': question_text,
                'scoring_guide': q['scoring_guide']
            })
        
        return questions
    
    def generate_calculation_questions(self, config):
        """生成计算题"""
        available_questions = self.question_database['calculation_questions']
        selected_questions = random.sample(available_questions, config['count'])
        
        questions = []
        for i, q in enumerate(selected_questions, 1):
            question_text = f"""
{q['context']['chinese']}

{q['context']['english']}

- {q['alternatives'][0]['description']['chinese']}
- {q['alternatives'][0]['description']['english']}
- {q['alternatives'][1]['description']['chinese']}
- {q['alternatives'][1]['description']['english']}
- {q['alternatives'][2]['description']['chinese']}
- {q['alternatives'][2]['description']['english']}

参数: 折现率={q['parameters']['discount_rate']*100}% 
时间系数: 5年={q['parameters']['time_periods']['5_year']}, 
         10年={q['parameters']['time_periods']['10_year']}, 
         20年={q['parameters']['time_periods']['20_year']}, 
         30年={q['parameters']['time_periods']['30_year']}

公式: {q['formula']}

要求: {q['requirements']['chinese']}
     {q['requirements']['english']}

附加要求: {q['additional_requirements']['chinese']}
          {q['additional_requirements']['english']}
            """.strip()
            
            questions.append({
                'type': 'calculation',
                'number': i,
                'content': question_text
            })
        
        return questions

# 使用示例
def main():
    # 试卷配置
    exam_config = {
        'school': '中南财经政法大学',
        'academic_year': '2025–2026学年第1学期',
        'course_name': '林业经济学',
        'paper_type': 'A',
        'course_code': 'B0600432',
        'exam_type': '闭卷、笔试',
        'question_types': {
            'single_choice': {
                'count': 5,
                'score_per_question': 2,
                'difficulty': 'medium'
            },
            'true_false': {
                'count': 5, 
                'score_per_question': 2
            },
            'essay': {
                'count': 2,
                'score_per_question': 15
            },
            'calculation': {
                'count': 1,
                'score_per_question': 20
            }
        }
    }
    
    generator = ForestEconomicsExamGenerator('question_database.json')
    exam_content = generator.generate_exam(exam_config)
    
    # 输出到文件
    with open('generated_exam.txt', 'w', encoding='utf-8') as f:
        f.write(f"{exam_content['header']}\n")
        f.write(f"{exam_content['score_table']['header']}\n")
        f.write(f"{exam_content['score_table']['scores']}\n")
        f.write(f"{exam_content['score_table']['points']}\n")
        
        for q in exam_content['questions']:
            f.write(f"\n{q['content']}\n")

if __name__ == '__main__':
    main()
```

## 3. 试卷模板文件

### 3.1 Word模板生成脚本
```python
from docx import Document
from docx.shared import Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
import json

def create_word_template(exam_content):
    """创建Word格式的试卷模板"""
    doc = Document()
    
    # 设置中文字体
    doc.styles['Normal'].font.name = '宋体'
    doc.styles['Normal']._element.rProp.rFonts.set(qn('w:eastAsia'), '宋体')
    
    # 添加标题
    title = doc.add_paragraph()
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER
    title.add_run(exam_content['header']).bold = True
    
    # 添加分值表
    table = doc.add_table(rows=4, cols=10)
    table.style = 'Table Grid'
    
    # 填充表头
    hdr_cells = table.rows[0].cells
    for i, text in enumerate(["题号", "一", "二", "三", "四", "五", "六", "七", "总分", "总分人"]):
        hdr_cells[i].text = text
    
    # 添加题目内容
    for q in exam_content['questions']:
        doc.add_paragraph(f"\n{q['content']}")
    
    # 保存文档
    doc.save('林业经济学试卷.docx')
    print("Word试卷已生成：林业经济学试卷.docx")

# 批量生成多套试卷
def batch_generate(count=5):
    """批量生成多套试卷"""
    generator = ForestEconomicsExamGenerator('question_database.json')
    
    for i in range(count):
        exam_config = {
            'school': '中南财经政法大学',
            'academic_year': '2025–2026学年第1学期',
            'course_name': '林业经济学',
            'paper_type': chr(65 + i % 26),  # A, B, C... 
            'course_code': 'B0600432',
            'exam_type': '闭卷、笔试',
            'question_types': {
                'single_choice': {'count': 5, 'score_per_question': 2, 'difficulty': 'medium'},
                'true_false': {'count': 5, 'score_per_question': 2},
                'essay': {'count': 2, 'score_per_question': 15},
                'calculation': {'count': 1, 'score_per_question': 20}
            }
        }
        
        exam_content = generator.generate_exam(exam_config)
        create_word_template(exam_content)
```

## 4. 使用说明

### 4.1 题库维护
1. 将题目按照类型分别存储在JSON文件中
2. 为每个题目标注难度、知识点、标签等元数据
3. 定期更新题库以保持内容时效性

### 4.2 试卷生成
1. 配置试卷参数（题型、数量、分值等）
2. 运行生成器脚本
3. 检查生成的试卷内容
4. 导出为Word格式

### 4.3 质量控制
1. 确保题目难度分布合理
2. 验证计算题参数准确性
3. 检查中英文对照一致性
4. 核对分值总计正确性

该模板系统可以实现林业经济学（双语）试卷的高效批量生成，确保试卷质量和标准化程度。