# 林业经济学试题管理系统 — 技术文档

## 目录

1. [系统概述](#1-系统概述)
2. [架构设计](#2-架构设计)
3. [数据库设计](#3-数据库设计)
4. [ORM 模型详解](#4-orm-模型详解)
5. [API 路由详解](#5-api-路由详解)
6. [应用工厂与配置](#6-应用工厂与配置)
7. [工具函数模块](#7-工具函数模块)
8. [数据迁移](#8-数据迁移)
9. [测试体系](#9-测试体系)
10. [数据流与业务逻辑](#10-数据流与业务逻辑)
11. [部署与运维](#11-部署与运维)

---

## 1. 系统概述

### 1.1 项目背景

本系统为林业经济学（双语）课程设计的试题管理平台，解决以下核心需求：

- 管理多题型（单选、多选、是非、简答、计算、论述、材料等，支持自定义扩展）试题库
- 支持中英文双语题目
- 自动从未使用题目中组卷，避免跨年度重复出题
- 从 Word/TXT 模板文件批量导入题目
- 导出格式化的 Word 试卷文件

### 1.2 技术选型

| 层级 | 技术 | 选型理由 |
|------|------|---------|
| Web 框架 | Flask 3.x | 轻量、灵活，适合中小型项目 |
| ORM | Flask-SQLAlchemy | 声明式模型定义，自动建表 |
| 数据库 | SQLite | 零配置、单文件部署、适合单用户场景 |
| 文档处理 | python-docx | 读写 `.docx` 文件的成熟库 |
| 测试 | pytest | 功能丰富、fixture 机制优秀 |
| 前端 | 原生 JS SPA | 无构建工具依赖，`index.html` 单文件 |

### 1.3 从 JSON 到 SQLite 的演进

系统最初使用 `question_bank.json` 文件存储所有数据，通过 `QuestionBank` 单例在内存中操作。每次修改都全量重写 JSON 文件。这种方式存在以下问题：

| 问题 | 描述 |
|------|------|
| 并发安全 | 多请求同时写入会导致数据丢失 |
| 无事务保障 | 写入中断会导致数据损坏 |
| 性能瓶颈 | 大数据量时每次全量序列化/反序列化效率低 |
| 查询能力弱 | 搜索需遍历全部数据，无索引支持 |

迁移至 SQLite + SQLAlchemy 后，以上问题全部解决。同时保持了所有 API 接口和 JSON 响应格式不变，前端代码无需任何修改。

---

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────┐
│                    浏览器 (SPA)                       │
│              app/templates/index.html                │
└──────────────────────┬──────────────────────────────┘
                       │ HTTP (fetch API)
                       ▼
┌─────────────────────────────────────────────────────┐
│                   Flask 应用层                        │
│                                                      │
│  server.py ──► factory.py ──► Blueprint (routes.py)  │
│                    │                                  │
│                    ▼                                  │
│              db.init_app()                            │
│              db.create_all()                          │
└──────────────────────┬──────────────────────────────┘
                       │ SQLAlchemy ORM
                       ▼
┌─────────────────────────────────────────────────────┐
│                   数据库层                            │
│                                                      │
│  db_models.py ──► QuestionTypeModel                   │
│               ──► QuestionModel                      │
│               ──► ExamModel                          │
│               ──► exam_questions (关联表)              │
│                                                      │
│  存储: exam_system.db (SQLite 文件)                   │
└─────────────────────────────────────────────────────┘
```

### 2.2 设计模式

- **应用工厂模式 (Application Factory)** — `create_app()` 函数根据配置名创建 Flask 实例，支持多环境切换
- **Blueprint** — 所有 API 路由注册在 `main` Blueprint 下
- **ORM 模式** — 通过 SQLAlchemy 模型类映射数据库表，不直接编写 SQL
- **多对多关联** — 试卷与题目通过 `exam_questions` 关联表建立关系，含 `position` 字段保持题序

### 2.3 文件职责说明

| 文件 | 职责 | 依赖 |
|------|------|------|
| `server.py` | 应用入口，创建并运行 Flask app | `factory.py` |
| `config.py` | 多环境配置类（开发/测试/生产） | 无 |
| `app/factory.py` | 应用工厂，初始化数据库、种子数据和 Blueprint | `db_models.py`, `routes.py`, `config.py` |
| `app/db_models.py` | SQLAlchemy ORM 模型定义（含 QuestionTypeModel） | `flask_sqlalchemy` |
| `app/routes.py` | 所有 REST API 路由和业务逻辑 | `db_models.py`, `utils.py` |
| `app/utils.py` | 工具函数（Word 导入/导出、文件验证） | `python-docx` |
| `app/models.py` | 旧版数据类定义（保留供参考） | 无 |
| `migrate_json_to_db.py` | JSON → SQLite 数据迁移脚本 | `factory.py`, `db_models.py` |

### 2.4 请求处理流程

```
客户端请求 ──► Flask 路由匹配 ──► 路由处理函数
                                      │
                                      ├── 解析请求参数/JSON body
                                      ├── SQLAlchemy 查询/修改
                                      ├── db.session.commit()
                                      └── 返回 JSON 响应
```

---

## 3. 数据库设计

### 3.1 ER 图

```
┌──────────────────────┐       ┌──────────────────────┐
│   question_types     │       │        exams         │
├──────────────────────┤       ├──────────────────────┤
│ PK id       (Auto)   │       │ PK exam_id      (64) │
│    name        (64)  │       │    name         (256)│
│    label       (64)  │       │    config      (Text)│
│    has_options (Bool) │       │    created_at   (DT) │
│    is_builtin  (Bool) │       │    updated_at   (DT) │
│    created_at   (DT) │       └──────────┬───────────┘
└──────────────────────┘                  │
                                          │
┌──────────────────────┐       ┌──────────┴───────────┐
│      questions       │       │   exam_questions      │
├──────────────────────┤       ├──────────────────────┤
│ PK question_id  (64) │◄──────┤ PK,FK question_id    │
│    question_type (32)│       │ PK,FK exam_id        │
│    content     (Text)│       │    position     (Int) │
│    options     (Text)│       └──────────────────────┘
│    answer      (Text)│
│    reference_answer  │
│    explanation (Text)│
│    content_en  (Text)│  ← 英文题目
│    options_en  (Text)│  ← 英文选项JSON
│    knowledge_point   │  ← 知识点
│    tags       (512)  │  ← 标签
│    difficulty  (32)  │  ← 难度
│    language     (10) │
│    metadata_json     │
│    is_used    (Bool) │
│    used_date    (DT) │
│    created_at   (DT) │
│    updated_at   (DT) │
└──────────────────────┘
```

### 3.2 表结构详解

#### `question_types` 表 — 题型

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `id` | `Integer` | **PK**, 自增 | 题型唯一标识 |
| `name` | `String(64)` | UNIQUE, NOT NULL | 题型标识名（如 `单选`、`简答>计算`） |
| `label` | `String(64)` | NOT NULL | 题型显示名（如 `单选题`、`计算题`） |
| `has_options` | `Boolean` | 默认 `False` | 是否为选择题（有选项） |
| `is_builtin` | `Boolean` | 默认 `False` | 是否为内置题型（不可删除） |
| `created_at` | `DateTime` | — | 创建时间 |

**内置题型（7 个）：** 系统首次启动时自动种子插入

| name | label | has_options |
|------|-------|-------------|
| 单选 | 单选题 | `True` |
| 多选 | 多选题 | `True` |
| 是非 | 是非题 | `True` |
| 简答 | 简答题 | `False` |
| 简答>计算 | 计算题 | `False` |
| 简答>论述 | 论述题 | `False` |
| 简答>材料分析 | 材料分析题 | `False` |

#### `questions` 表 — 题目

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `question_id` | `String(64)` | **PK** | 题目唯一标识（如 `q_20260112_130149_0`） |
| `question_type` | `String(32)` | NOT NULL, INDEX | 题型（单选/多选/是非/简答/计算/论述/材料） |
| `content` | `Text` | NOT NULL | 题目内容 |
| `options` | `Text` | 默认 `'[]'` | 选项列表，JSON 字符串（如 `'["A选项","B选项"]'`） |
| `answer` | `Text` | 可为 NULL | 标准答案（选择题为字母如 `"A"`/`"ABD"`） |
| `reference_answer` | `Text` | 可为 NULL | 参考答案（简答/论述题使用） |
| `explanation` | `Text` | 可为 NULL | 题目解析 |
| `content_en` | `Text` | 可为 NULL | 英文题目内容 |
| `options_en` | `Text` | 可为 NULL | 英文选项，JSON 字符串（如 `'["Option A","Option B"]'`） |
| `knowledge_point` | `String(256)` | 可为 NULL | 知识点（如"林业经济基础"） |
| `tags` | `String(512)` | 可为 NULL | 标签，逗号分隔（如 `"基础,概念,林业"`） |
| `difficulty` | `String(32)` | 可为 NULL | 难度等级（`easy`/`medium`/`hard`） |
| `language` | `String(10)` | 默认 `'zh'`, INDEX | 语言标记（`zh`/`en`/`both`），提供 `content_en` 时自动设为 `both` |
| `metadata_json` | `Text` | 默认 `'{}'` | 扩展元数据，JSON 字符串 |
| `is_used` | `Boolean` | 默认 `False`, INDEX | 是否已在试卷中使用 |
| `used_date` | `DateTime` | 可为 NULL | 使用日期 |
| `created_at` | `DateTime` | — | 创建时间 |
| `updated_at` | `DateTime` | — | 最后更新时间 |

**索引说明：** 在 `question_type`、`language`、`is_used` 三个字段上建有索引，用于加速按题型筛选、按语言过滤和查找未使用题目的查询。

**JSON 存储新增字段：** `options_en` 与 `options` 格式相同，存储英文选项的 JSON 数组。在 `to_dict()` 中自动反序列化为 list。

#### `exams` 表 — 试卷

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `exam_id` | `String(64)` | **PK** | 试卷唯一标识 |
| `name` | `String(256)` | NOT NULL | 试卷名称 |
| `config` | `Text` | 默认 `'{}'` | 组卷配置，JSON 字符串 |
| `created_at` | `DateTime` | — | 创建时间 |
| `updated_at` | `DateTime` | — | 最后更新时间 |

**config 字段格式示例：**

```json
{
  "单选": {"count": 10, "points": 2},
  "是非": {"count": 5, "points": 1},
  "简答": {"count": 3, "points": 10}
}
```

含义：10 道单选题每题 2 分，5 道是非题每题 1 分，3 道简答题每题 10 分，总分 55 分。

#### `exam_questions` 表 — 试卷-题目关联

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `exam_id` | `String(64)` | **PK**, FK → `exams.exam_id` | 试卷 ID |
| `question_id` | `String(64)` | **PK**, FK → `questions.question_id` | 题目 ID |
| `position` | `Integer` | — | 题目在试卷中的顺序（0 起始） |

复合主键 `(exam_id, question_id)` 确保同一题目不会在同一试卷中重复出现。`position` 字段确保题目按添加顺序排列。

### 3.3 JSON 存储字段设计决策

SQLite 没有原生 JSON 类型，以下字段使用 `Text` 类型存储 JSON 字符串：

| 字段 | 存储示例 | 读取时处理 |
|------|---------|-----------|
| `options` | `'["选项A","选项B","选项C","选项D"]'` | `json.loads()` → `list` |
| `options_en` | `'["Option A","Option B","Option C","Option D"]'` | `json.loads()` → `list`（为 NULL 时返回 `[]`） |
| `metadata_json` | `'{"source":"textbook","chapter":3}'` | `json.loads()` → `dict` |
| `config` | `'{"单选":{"count":10,"points":2}}'` | `json.loads()` → `dict` |

写入时使用 `json.dumps(data, ensure_ascii=False)` 保证中文字符正确存储。

---

## 4. ORM 模型详解

文件位置：`app/db_models.py`

### 4.1 QuestionTypeModel

```python
class QuestionTypeModel(db.Model):
    __tablename__ = 'question_types'
    id          = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name        = db.Column(db.String(64), unique=True, nullable=False)
    label       = db.Column(db.String(64), nullable=False)
    has_options = db.Column(db.Boolean, default=False)
    is_builtin  = db.Column(db.Boolean, default=False)
    created_at  = db.Column(db.DateTime, default=datetime.now)
```

**关键方法：**

- `to_dict()` — 将模型转换为 dict，包含所有字段。时间字段转为 ISO 格式字符串。

**设计说明：** `name` 字段设为 UNIQUE，确保题型标识唯一。`is_builtin` 标记内置题型，API 层禁止删除 `is_builtin=True` 的记录。`has_options` 用于前端判断添加题目时是否显示选项输入框以及模板生成时选择不同的格式。

### 4.2 QuestionModel

```python
class QuestionModel(db.Model):
    __tablename__ = 'questions'
    question_id    = db.Column(db.String(64), primary_key=True)
    question_type  = db.Column(db.String(32), nullable=False, index=True)
    content        = db.Column(db.Text, nullable=False)
    options        = db.Column(db.Text, default='[]')
    answer         = db.Column(db.Text)
    reference_answer = db.Column(db.Text)
    explanation    = db.Column(db.Text)
    content_en     = db.Column(db.Text, nullable=True)       # 英文题目
    options_en     = db.Column(db.Text, nullable=True)       # 英文选项 JSON
    knowledge_point = db.Column(db.String(256), nullable=True)
    tags           = db.Column(db.String(512), nullable=True) # 逗号分隔
    difficulty     = db.Column(db.String(32), nullable=True)  # easy/medium/hard
    language       = db.Column(db.String(10), default='zh', index=True)
    metadata_json  = db.Column(db.Text, default='{}')
    is_used        = db.Column(db.Boolean, default=False, index=True)
    used_date      = db.Column(db.DateTime)
    created_at     = db.Column(db.DateTime)
    updated_at     = db.Column(db.DateTime)
```

**关键方法：**

- `to_dict()` — 将模型转换为 dict，自动反序列化 JSON 字段（`options` → list，`options_en` → list，`metadata_json` → dict），时间字段转为 ISO 格式字符串。返回值直接用于 API JSON 响应。

### 4.3 ExamModel

```python
class ExamModel(db.Model):
    __tablename__ = 'exams'
    exam_id    = db.Column(db.String(64), primary_key=True)
    name       = db.Column(db.String(256), nullable=False)
    config     = db.Column(db.Text, default='{}')
    created_at = db.Column(db.DateTime)
    updated_at = db.Column(db.DateTime)

    questions = db.relationship('QuestionModel', secondary=exam_questions,
                    backref=db.backref('exams', lazy='dynamic'), lazy='dynamic')
```

**关键方法：**

| 方法 | 说明 |
|------|------|
| `to_dict()` | 转换为 dict，包含按 `position` 排序的题目列表 |
| `get_ordered_questions()` | 返回按 `position` 排序的 `QuestionModel` 列表 |
| `calculate_total_score()` | 根据 `config` 中每种题型的 `points` 值和实际题目数量计算总分 |

**`to_dict()` 中的排序查询：**

```python
ordered_questions = db.session.query(QuestionModel).join(
    exam_questions,
    QuestionModel.question_id == exam_questions.c.question_id
).filter(
    exam_questions.c.exam_id == self.exam_id
).order_by(exam_questions.c.position).all()
```

这个查询通过 JOIN `exam_questions` 关联表，按 `position` 字段升序排列，确保题目顺序与添加顺序一致。

### 4.4 exam_questions 关联表

```python
exam_questions = db.Table('exam_questions',
    db.Column('exam_id', db.String(64), db.ForeignKey('exams.exam_id'), primary_key=True),
    db.Column('question_id', db.String(64), db.ForeignKey('questions.question_id'), primary_key=True),
    db.Column('position', db.Integer)
)
```

这是 SQLAlchemy 的 `Table` 对象（非 ORM 模型），用于定义多对多关系。直接通过 `db.session.execute()` 操作。

---

## 5. API 路由详解

文件位置：`app/routes.py`

所有路由注册在 `main` Blueprint 下，请求和响应均为 JSON 格式（文件下载除外）。

### 5.1 题目管理 API

#### `GET /api/questions` — 获取/搜索题目

**查询参数：**

| 参数 | 类型 | 说明 |
|------|------|------|
| `keyword` | string | 按题目内容模糊搜索 |
| `type` | string | 按题型精确过滤（如 `单选`） |
| `language` | string | 按语言精确过滤（`zh`/`en`/`both`） |
| `difficulty` | string | 按难度精确过滤（`easy`/`medium`/`hard`） |
| `knowledge_point` | string | 按知识点模糊搜索 |
| `is_used` | string | 按使用状态过滤（`1` 已使用、`0` 未使用） |

六个参数可组合使用，均为可选。不传参数则返回全部题目。

**实现：** 使用 SQLAlchemy 链式查询构建动态过滤条件：

```python
query = QuestionModel.query
if keyword:
    query = query.filter(QuestionModel.content.contains(keyword))
if question_type:
    query = query.filter_by(question_type=question_type)
if language:
    query = query.filter_by(language=language)
if difficulty:
    query = query.filter_by(difficulty=difficulty)
if knowledge_point:
    query = query.filter(QuestionModel.knowledge_point.contains(knowledge_point))
if is_used == '1':
    query = query.filter_by(is_used=True)
elif is_used == '0':
    query = query.filter_by(is_used=False)
```

**响应示例：**

```json
[
  {
    "question_id": "q_20260112_130149_0",
    "question_type": "单选",
    "content": "Python是什么类型的语言？",
    "options": ["编译型", "解释型", "汇编型", "机器型"],
    "answer": "B",
    "reference_answer": null,
    "explanation": "Python是解释型语言",
    "content_en": "What type of language is Python?",
    "options_en": ["Compiled", "Interpreted", "Assembly", "Machine"],
    "knowledge_point": "编程语言基础",
    "tags": "基础,编程",
    "difficulty": "easy",
    "language": "both",
    "metadata": {},
    "is_used": false,
    "used_date": null,
    "created_at": "2026-01-12T13:01:49.058055",
    "updated_at": "2026-01-12T13:01:49.058055"
  }
]
```

#### `POST /api/questions` — 新增题目

**请求体 (JSON)：**

```json
{
  "question_id": "q_001",
  "question_type": "单选",
  "content": "题目内容",
  "options": ["选项A", "选项B", "选项C", "选项D"],
  "answer": "A",
  "reference_answer": null,
  "explanation": "解析内容",
  "language": "zh",
  "content_en": "Question content in English",
  "options_en": ["Option A", "Option B", "Option C", "Option D"],
  "knowledge_point": "知识点名称",
  "tags": "标签1,标签2",
  "difficulty": "medium",
  "metadata": {}
}
```

**业务逻辑：**
1. 从请求 JSON 中提取字段（含双语和元数据字段）
2. `options`、`options_en` 和 `metadata` 序列化为 JSON 字符串存入数据库
3. 自动设置 `created_at` 和 `updated_at` 为当前时间
4. **自动语言检测**：如果提供了 `content_en` 且 `language` 为 `zh`，自动升级为 `both`
5. 如果 `question_id` 重复，返回 400 错误（IntegrityError 捕获并回滚）

**响应：** `201 Created`，返回创建的题目对象

#### `GET /api/questions/<question_id>` — 获取单个题目

- 存在：返回 200 + 题目 JSON
- 不存在：返回 404 + `{"error": "Question not found"}`

#### `PUT /api/questions/<question_id>` — 更新题目

**请求体：** 仅需包含要更新的字段（部分更新）

```json
{
  "content": "更新后的内容",
  "answer": "B"
}
```

**业务逻辑：** 仅更新请求中包含的字段（含 `content_en`、`options_en`、`knowledge_point`、`tags`、`difficulty`），未提及的字段保持不变。如果更新后 `content_en` 有值且 `language` 仍为 `zh`，自动升级为 `both`。自动更新 `updated_at`。

#### `DELETE /api/questions/<question_id>` — 删除题目

返回 `{"message": "Question deleted successfully"}` 或 404。

#### `POST /api/questions/import` — 文件导入

**请求：** `multipart/form-data`，字段名 `file`

**支持的文件类型：**

| 类型 | 处理方式 |
|------|---------|
| `.txt` | 直接调用 `parse_question_template()` 解析 |
| `.docx` | 先调用 `word_to_csv_converter` 转为 CSV，再解析 |

**业务逻辑：**
1. 验证文件存在性和类型
2. 保存到 `temp/` 临时目录
3. 解析题目数据
4. 使用 `db.session.add_all()` 批量插入，一次 `commit()`（而非逐条提交）
5. 清理临时文件
6. 出错时 `db.session.rollback()` 回滚事务

**响应：** `{"message": "Questions imported successfully", "count": 15}`

#### `POST /api/questions/batch-delete` — 批量删除题目

**请求体 (JSON)：**

```json
{
  "question_ids": ["q_001", "q_002", "q_003"]
}
```

**业务逻辑：**
1. 验证 `question_ids` 列表非空（空列表返回 400）
2. 先删除 `exam_questions` 关联表中涉及这些题目的所有记录
3. 再删除 `questions` 表中存在的对应记录
4. 不存在的 ID 静默跳过，不报错

**响应：** `{"deleted_count": 2}` — 返回实际删除的题目数量

#### `POST /api/questions/batch-update-type` — 批量修改题型

**请求体 (JSON)：**

```json
{
  "question_ids": ["q_001", "q_002", "q_003"],
  "question_type": "多选"
}
```

**业务逻辑：**
1. 验证 `question_ids` 列表和 `question_type` 均非空
2. 验证目标题型在 `question_types` 表中存在
3. 使用 `QuestionModel.query.filter(...).update()` 批量更新，一次性提交
4. 返回实际更新的数量

**响应：** `{"message": "3 questions updated to \"多选\"", "updated_count": 3}`

#### `POST /api/questions/batch-release` — 批量释放题目

**请求体 (JSON)：**

```json
{
  "question_ids": ["q_001", "q_002", "q_003"]
}
```

**业务逻辑：**
1. 验证 `question_ids` 列表非空（空列表返回 400）
2. 遍历 ID 列表，将 `is_used=True` 的题目标记为 `is_used=False`，清除 `used_date`
3. 不存在的 ID 或已经为未使用状态的题目静默跳过
4. 返回实际释放的数量

**响应：** `{"message": "2 questions released", "released_count": 2}`

#### `GET /api/questions/export` — 导出题库

**查询参数：** `format=json`（默认）或 `format=csv`

**业务逻辑：**
1. 查询全部题目
2. 生成带时间戳的文件名
3. 写入 `exports/` 目录
4. 返回文件下载

### 5.2 试卷管理 API

#### `POST /api/exams` — 创建试卷

**请求体：**

```json
{
  "exam_id": "exam_2026_final",
  "name": "2026年期末考试",
  "config": {
    "单选": {"count": 10, "points": 2},
    "是非": {"count": 5, "points": 1},
    "简答": {"count": 3, "points": 10}
  }
}
```

**注意：** `exam_id` 为可选字段。如果未提供或为空，系统使用 `uuid.uuid4()` 自动生成（格式：`exam_xxxxxxxx`）。

#### `POST /api/exams/generate` — 自动组卷

这是系统最核心的业务逻辑。

**请求体：** 同创建试卷（`exam_id` 同样可省略，自动生成）

**业务逻辑：**

```
遍历 config 中的每种题型:
    1. 查询该题型中 is_used=False 的未使用题目
    2. 使用 db.func.trim() 处理题型名称的空格差异
    3. 取前 count 道题目
    4. 在 exam_questions 关联表中插入记录，分配递增的 position
最终一次性 commit() 提交所有更改

注意：组卷时不会标记题目为已使用（is_used 不变），
只有通过 confirm 确认试卷后才会标记为已使用。
```

**关键 SQL 查询：**

```python
QuestionModel.query.filter(
    db.func.trim(QuestionModel.question_type) == question_type.strip(),
    QuestionModel.is_used == False
).limit(count).all()
```

`db.func.trim()` 处理了题型名称前后可能存在的空格，确保 ` 单选 ` 和 `单选` 能匹配。

**题目不足时的行为：** 不报错，有多少选多少。例如请求 10 道单选题但只有 3 道未使用，则试卷中只包含 3 道。

#### `POST /api/exams/<id>/add_question` — 添加题目到试卷

**请求体：** `{"question_id": "q_001"}`

**业务逻辑：**
1. 验证试卷和题目都存在
2. 查询当前最大 `position` 值
3. 在关联表中插入新记录，`position = max_position + 1`

#### `DELETE /api/exams/<id>/remove_question/<qid>` — 从试卷移除题目

直接删除关联表中的对应记录。

#### `POST /api/exams/<id>/replace_question` — 替换题目

**请求体：**

```json
{
  "old_question_id": "q_001",
  "new_question_id": "q_002"
}
```

**业务逻辑：**
1. 验证旧题目在试卷中存在（通过 `exam_questions` 查询）
2. 验证新题目存在
3. 验证新旧题目类型相同（不同类型返回 400）
4. 关联表中删除旧记录、插入新记录，保持相同的 `position`

**注意：** 替换操作不会修改任何题目的 `is_used` 状态。使用状态仅由确认（confirm）和撤销确认（revert）管理。

#### `POST /api/exams/<id>/confirm` — 确认试卷

将试卷中所有题目标记为 `is_used=True`。用于最终定稿后锁定题目。

#### `POST /api/exams/<id>/revert_confirmation` — 撤销确认

将试卷中所有题目标记为 `is_used=False`，`used_date=None`。

#### `GET /api/exams/<id>/export` — 导出 Word 试卷

**查询参数：**

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `mode` | string | `zh` | 语言模式：`zh`（纯中文）、`en`（纯英文）、`both`（中英对照） |
| `show_answer` | string | `1` | 是否包含答案：`1`（含答案/解析）、`0`（仅题目） |

调用 `utils.export_exam_to_word(exam, filepath, mode, show_answer)` 生成 `.docx` 文件并返回下载。

#### `DELETE /api/exams/<id>` — 删除试卷

**业务逻辑：** 先删除 `exam_questions` 关联表中该试卷的所有记录，再删除试卷本体。注意：不会删除题目本身，也不会改变题目的 `is_used` 状态。

### 5.3 题型管理 API

#### `GET /api/question-types` — 获取所有题型

返回按 `id` 升序排列的所有题型列表（含内置和自定义）。

**响应示例：**

```json
[
  {"id": 1, "name": "单选", "label": "单选题", "has_options": true, "is_builtin": true, "created_at": "2026-01-12T10:00:00"},
  {"id": 8, "name": "简答>案例", "label": "案例分析题", "has_options": false, "is_builtin": false, "created_at": "2026-02-13T14:30:00"}
]
```

#### `POST /api/question-types` — 创建自定义题型

**请求体：**

```json
{
  "name": "简答>案例",
  "label": "案例分析题",
  "has_options": false
}
```

**校验规则：**
- `name` 不能为空
- `name` 不能与已有题型重复（返回 400 + `"already exists"` 错误）

**响应：** `201 Created`，返回创建的题型对象（`is_builtin` 自动设为 `false`）

#### `PUT /api/question-types/<id>` — 更新题型

支持部分更新，可修改 `name`、`label`、`has_options`。如果修改 `name`，需保证唯一性。

#### `DELETE /api/question-types/<id>` — 删除题型

**校验规则：**
- 不存在的 ID 返回 404
- 内置题型（`is_builtin=True`）不可删除（返回 400 + `"built-in"` 错误）
- 有题目引用该题型时不可删除（返回 400 + `"questions use this type"` 错误）

---

## 6. 应用工厂与配置

### 6.1 应用工厂

文件位置：`app/factory.py`

```python
def create_app(config_name=None):
    if config_name is None:
        config_name = os.environ.get('FLASK_ENV', 'default')

    app = Flask(__name__)
    app.config.from_object(config[config_name])

    # 初始化数据库
    db.init_app(app)
    with app.app_context():
        db.create_all()          # 自动创建不存在的表
        _seed_question_types()   # 种子数据：内置题型

    # 注册 Blueprint
    app.register_blueprint(bp)

    return app
```

**`_seed_question_types()` 种子函数：**

当 `question_types` 表为空时，自动插入 7 个内置题型（单选/多选/是非/简答/简答>计算/简答>论述/简答>材料分析）。已有数据时跳过，保证幂等性。

**初始化顺序：**
1. 创建 Flask 实例
2. 加载配置
3. `db.init_app(app)` — 将 SQLAlchemy 绑定到 Flask 应用
4. `db.create_all()` — 根据模型定义自动创建数据库表（幂等操作，已存在的表不会重建）
5. `_seed_question_types()` — 检查并插入内置题型种子数据
6. 注册 Blueprint

### 6.2 配置体系

文件位置：`config.py`

```python
class Config:                      # 基础配置
    SECRET_KEY = 'dev-secret-key-change-in-production'
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024   # 16MB
    SQLALCHEMY_DATABASE_URI = 'sqlite:///exam_system.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False

class DevelopmentConfig(Config):   # 开发环境
    DEBUG = True

class TestingConfig(Config):       # 测试环境
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite://'  # 内存数据库

class ProductionConfig(Config):    # 生产环境
    DEBUG = False
```

**测试环境使用内存数据库（`sqlite://`）：**
- 每次测试创建全新的数据库
- 测试结束自动销毁
- 完全隔离，不影响磁盘上的 `exam_system.db`
- 运行速度极快（无磁盘 I/O）

---

## 7. 工具函数模块

文件位置：`app/utils.py`

### 7.1 `allowed_file(filename)`

验证上传文件扩展名是否在允许列表中。

允许的扩展名：`txt`, `pdf`, `png`, `jpg`, `jpeg`, `gif`, `doc`, `docx`, `csv`

### 7.2 `generate_word_template()`

**动态**生成题库导入模板的 `.docx` 文件。从数据库查询所有已注册题型（含自定义题型），根据 `has_options` 字段生成对应格式的示例段落：
- 选择题（`has_options=True`）：生成带 `[A][B][C][D]` 中文选项和 `[A_en][B_en][C_en][D_en]` 英文选项的示例
- 非选择题（`has_options=False`）：生成带 `<参考答案>...</参考答案>` 的示例
- 所有示例的 `<解析>` 区段中包含元数据行示例：`知识点:`、`标签:`、`英文题目:`、`难度:`

返回值：模板文件路径（存放在 `temp/question_template.docx`）

### 7.3 `export_exam_to_word(exam, filepath, mode='zh', show_answer=True)`

将 `ExamModel` 实例导出为格式化的 Word 文档。

**参数：**

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `exam` | ExamModel | — | 试卷 ORM 实例 |
| `filepath` | str | — | 输出文件路径 |
| `mode` | str | `'zh'` | 语言模式：`zh`（纯中文）、`en`（纯英文）、`both`（中英对照） |
| `show_answer` | bool | `True` | 是否包含答案、参考答案和解析 |

**文档结构：**
1. 试卷标题（居中）
2. 考试信息（名称、生成时间、总分）
3. 按题型分组的题目列表
   - 每组一个一级标题
   - 题目内容加粗
   - 选择题显示选项（A/B/C/D）
   - `mode='en'` 时优先使用英文内容，不存在则回退到中文
   - `mode='both'` 时中英对照显示（选项用 `/` 分隔）
   - `show_answer=True` 时显示答案、参考答案、解析

**选项处理：** ORM 模型的选项需要从 JSON 字符串反序列化：

```python
options_zh = json.loads(question.options) if question.options else []
options_en = json.loads(question.options_en) if question.options_en else []
```

### 7.4 `parse_question_template(content)`

解析文本格式的题目模板，返回题目字典列表。

**支持的格式标记：**

| 标记 | 说明 |
|------|------|
| `[题型名]` | 题型标识（通用匹配，支持任意已注册题型） |
| `[A]`、`[B]`、`[C]`、`[D]` | 答案标识（紧跟题型后） |
| `[A]选项内容` | 中文选项行 |
| `[A_en]选项内容` | 英文选项行（紧跟中文选项后） |
| `<解析>...</解析>` | 解析内容（可选） |
| `<参考答案>...</参考答案>` | 参考答案（可选，注意闭合标签用 `</参考答案>`） |
| `（中文）`/`（英文）` | 双语标记（可选） |
| `[简答>论述]` | 题型子类型（`>` 分隔） |

**解析区段内支持的元数据行：**

| 格式 | 说明 | 映射字段 |
|------|------|---------|
| `知识点:xxx` | 知识点标注 | `knowledge_point` |
| `标签:xxx,yyy` | 逗号分隔标签 | `tags` |
| `英文题目:xxx` | 英文题目内容 | `content_en` |
| `难度:easy\|medium\|hard` | 难度等级 | `difficulty` |

这些元数据行会从解析内容中分离出来，不会包含在最终的 `explanation` 字段中。

---

## 8. 数据迁移

文件位置：`migrate_json_to_db.py`

### 8.1 迁移流程

```
读取 question_bank.json
    │
    ▼
去重题目 (按 question_id，保留最后出现的)
    │
    ▼
写入 questions 表
    │
    ▼
去重试卷 (按 exam_id，保留最后出现的)
    │
    ▼
写入 exams 表 + exam_questions 关联
    │
    ▼
db.session.commit() 一次性提交
```

### 8.2 去重策略

旧版 JSON 数据中存在以下重复问题：

| 重复类型 | 原因 | 处理方式 |
|---------|------|---------|
| 题目 ID 重复 | 旧系统未做唯一性检查 | 保留最后出现的记录 |
| 试卷 ID 重复 | 同上 | 保留最后出现的记录 |
| 试卷内题目 ID 重复 | 题目被多次添加到同一试卷 | 跳过已存在的关联 |
| 试卷引用不存在的题目 | 题目被删除后试卷未更新 | 跳过不存在的题目 |

**实现代码：**

```python
# 题目去重
question_map = {}
for q in data.get('questions', []):
    question_map[q['question_id']] = q  # 后出现的覆盖前面的

# 试卷内题目去重
seen_exam_qids = set()
for q_data in e.get('questions', []):
    qid = q_data['question_id']
    if qid in question_map and qid not in seen_exam_qids:
        seen_exam_qids.add(qid)
        # 插入关联记录...
```

### 8.3 运行方式

```bash
python migrate_json_to_db.py
```

输出示例：`迁移完成：57 道题目（原始 69 条，去重后），16 份试卷`

**注意：** 脚本执行 `db.drop_all()` + `db.create_all()`，会清空现有数据库后重建。适合一次性迁移，不适合增量同步。

---

## 9. 测试体系

### 9.1 测试架构

```
tests/
├── conftest.py             # 共享 fixtures 和辅助函数
├── test_models.py          # ORM 模型单元测试
├── test_question_api.py    # 题库 API 集成测试
├── test_exam_api.py        # 试卷 API 集成测试
├── test_business_logic.py  # 业务逻辑测试
├── test_edge_cases.py      # 边界情况测试
├── test_question_types.py  # 题型管理 API 测试
├── test_batch_delete.py    # 批量删除 API 测试
└── test_usage_management.py # 使用管理 API 测试
```

### 9.2 Fixtures 设计

定义在 `tests/conftest.py`：

| Fixture | 作用域 | 说明 |
|---------|--------|------|
| `app` | function | 创建测试 Flask 应用（内存 SQLite），每个测试函数独立 |
| `client` | function | Flask 测试客户端 |
| `db` | function | 数据库 session |
| `sample_question_data` | function | 单选题样本 JSON 数据 |
| `sample_exam_data` | function | 试卷样本 JSON 数据 |

**辅助函数：**

| 函数 | 说明 |
|------|------|
| `create_question_in_db(db, ...)` | 直接向数据库插入题目，支持 `content_en`/`options_en`/`knowledge_point`/`tags`/`difficulty` 参数 |
| `create_exam_in_db(db, ...)` | 直接向数据库插入试卷（含关联），用于准备测试数据 |

**测试隔离机制：**

```python
@pytest.fixture
def app():
    app = create_app('testing')        # 使用内存数据库
    with app.app_context():
        _db.create_all()               # 创建表
        yield app
        _db.session.remove()           # 清理 session
        _db.drop_all()                 # 删除所有表
```

每个测试函数都获得全新的数据库，测试之间完全隔离。

### 9.3 测试用例清单

#### `test_models.py` — ORM 模型测试 (13 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestQuestionModel | `test_create_question_model` | 创建题目、字段赋值正确 |
| | `test_question_to_dict` | `to_dict()` 输出格式、options 反序列化 |
| | `test_question_options_json` | options 作为 JSON 存储和读取 |
| | `test_question_metadata_json` | metadata 作为 JSON 存储和读取 |
| | `test_question_is_used_default` | `is_used` 默认值为 `False` |
| | `test_question_timestamps` | 时间戳正确设置和序列化 |
| | `test_question_nullable_fields` | 可为 NULL 的字段正确处理 |
| TestExamModel | `test_create_exam_model` | 创建试卷、字段赋值正确 |
| | `test_exam_to_dict` | `to_dict()` 输出格式 |
| | `test_exam_question_relationship` | 多对多关系的添加和删除 |
| | `test_exam_config_json` | config 的 JSON 存储和读取 |
| | `test_exam_calculate_total_score` | 总分计算逻辑 |
| | `test_exam_get_ordered_questions` | 题目按 position 排序 |

#### `test_question_api.py` — 题库 API 测试 (22 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestAddQuestion | `test_add_question` | POST 返回 201，数据正确 |
| | `test_add_question_single_choice` | 单选题创建 |
| | `test_add_question_true_false` | 是非题创建 |
| | `test_add_question_essay` | 论述题创建 |
| | `test_add_question_calculation` | 计算题创建 |
| | `test_add_question_material` | 材料题创建 |
| TestGetQuestions | `test_get_questions_empty` | 空库返回空列表 |
| | `test_get_questions_list` | 返回正确列表 |
| | `test_get_question_by_id` | 按 ID 获取 |
| | `test_get_question_not_found` | 404 处理 |
| TestUpdateQuestion | `test_update_question` | PUT 修改内容 |
| | `test_update_question_not_found` | 404 处理 |
| TestDeleteQuestion | `test_delete_question` | DELETE 后再查为 404 |
| | `test_delete_question_not_found` | 404 处理 |
| TestSearchQuestions | `test_search_by_keyword` | 关键词搜索 |
| | `test_search_by_type` | 题型过滤 |
| | `test_search_by_language` | 语言过滤 |
| | `test_search_combined` | 多条件组合 |
| | `test_search_no_results` | 无结果返回空列表 |
| TestImportExport | `test_import_txt_file` | TXT 文件导入 |
| | `test_import_no_file` | 无文件返回 400 |
| | `test_export_invalid_format` | 无效格式返回 400 |

#### `test_exam_api.py` — 试卷 API 测试 (20 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestCreateExam | `test_create_exam` | POST 返回 201 |
| | `test_get_exams_empty` | 空列表 |
| | `test_get_exams_list` | 正确列表 |
| TestGetExam | `test_get_exam_by_id` | 按 ID 获取 |
| | `test_get_exam_not_found` | 404 |
| TestUpdateExam | `test_update_exam` | 修改名称和配置 |
| TestDeleteExam | `test_delete_exam` | 删除试卷 |
| TestExamQuestionOperations | `test_add_question_to_exam` | 添加题目到试卷 |
| | `test_add_nonexistent_question_to_exam` | 添加不存在的题目返回 404 |
| | `test_remove_question_from_exam` | 移除题目 |
| TestGenerateExam | `test_generate_exam` | 自动组卷 |
| | `test_generate_exam_insufficient_questions` | 题目不足时的行为 |
| TestConfirmRevert | `test_confirm_exam` | 确认试卷 |
| | `test_confirm_marks_questions_used` | 确认后 `is_used=True` |
| | `test_revert_confirmation` | 撤销确认 |
| | `test_revert_marks_questions_unused` | 撤销后 `is_used=False` |
| TestReplaceQuestion | `test_replace_question` | 替换题目 |
| | `test_replace_question_wrong_type` | 不同类型返回 400 |
| TestExportExam | `test_export_exam_not_found` | 不存在返回 404 |
| | `test_export_exam_to_word` | Word 导出成功 |

#### `test_business_logic.py` — 业务逻辑测试 (10 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestUsageTracking | `test_unused_questions_filter` | 仅筛选未使用题目 |
| | `test_generate_selects_unused_only` | 组卷只选未使用题目 |
| | `test_generate_does_not_mark_used` | 组卷不标记已使用（仅确认时标记） |
| | `test_confirm_marks_then_generate_no_overlap` | 确认后再组卷不重复 |
| | `test_replace_does_not_change_used_flags` | 替换不改变使用状态 |
| TestBilingualSupport | `test_bilingual_question` | `language='both'` 双语题目 |
| | `test_question_type_whitespace_handling` | 题型空格处理 |
| TestTemplateAndExport | `test_template_download` | 模板下载 |
| | `test_word_export_content` | Word 导出内容 |
| | *(此类共 2 个测试)* | |

#### `test_edge_cases.py` — 边界情况测试 (9 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestInputValidation | `test_add_question_missing_fields` | 缺少字段处理 |
| | `test_add_question_empty_content` | 空内容处理 |
| TestSpecialContent | `test_question_special_characters` | 引号、换行、HTML 标签 |
| | `test_question_unicode_content` | 中英文混合 |
| | `test_very_long_content` | 超长内容（5000 字） |
| TestDuplicateHandling | `test_duplicate_question_id` | 重复 ID 返回错误 |
| TestEmptyExamOperations | `test_empty_exam_operations` | 空试卷的确认/撤销 |
| | `test_exam_with_no_config` | 无配置试卷 |
| TestDataIntegrity | `test_concurrent_data_integrity` | 快速连续操作的数据一致性 |
| TestIndexPage | `test_index_page` | 首页返回 HTML |

#### `test_question_types.py` — 题型管理 API 测试 (10 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestQuestionTypeCRUD | `test_get_question_types_returns_builtin` | 种子数据返回 7 个内置题型 |
| | `test_create_custom_type` | 创建自定义题型 |
| | `test_create_duplicate_name_fails` | 重复名称返回 400 |
| | `test_create_empty_name_fails` | 空名称返回 400 |
| | `test_update_question_type` | 更新题型标签 |
| | `test_update_duplicate_name_fails` | 更新为重复名称返回 400 |
| | `test_delete_custom_type` | 删除自定义题型 |
| | `test_delete_builtin_fails` | 删除内置题型返回 400 |
| | `test_delete_referenced_type_fails` | 删除有题目引用的题型返回 400 |
| | `test_delete_nonexistent_type` | 删除不存在的题型返回 404 |

#### `test_usage_management.py` — 使用管理 API 测试 (7 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestUsageManagement | `test_filter_used_questions` | `is_used=1` 过滤已使用题目 |
| | `test_filter_unused_questions` | `is_used=0` 过滤未使用题目 |
| | `test_batch_release_questions` | 批量释放标记 `is_used=False`、清除 `used_date` |
| | `test_batch_release_empty_list` | 空列表返回 400 |
| | `test_batch_release_already_unused` | 已未使用的题目 `released_count=0` |
| | `test_batch_release_partial` | 混合已使用/未使用/不存在的 ID |
| | `test_filter_used_combined_with_type` | `is_used` 与 `type` 组合过滤 |

#### `test_batch_delete.py` — 批量删除 API 测试 (5 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestBatchDelete | `test_batch_delete_multiple_questions` | 批量删除多题，未删的仍存在 |
| | `test_batch_delete_empty_list` | 空列表返回 400 |
| | `test_batch_delete_cleans_exam_associations` | 删除后试卷关联自动清理 |
| | `test_batch_delete_partial_existing` | 部分存在的 ID，只删存在的 |
| | `test_batch_delete_all_nonexistent` | 全部不存在返回 deleted_count=0 |

### 9.4 运行测试

```bash
# 运行全部测试
python -m pytest tests/ -v

# 运行特定测试文件
python -m pytest tests/test_models.py -v

# 运行特定测试类
python -m pytest tests/test_exam_api.py::TestGenerateExam -v

# 运行特定测试用例
python -m pytest tests/test_business_logic.py::TestUsageTracking::test_generate_selects_unused_only -v

# 查看测试覆盖率（需安装 pytest-cov）
pip install pytest-cov
python -m pytest tests/ --cov=app --cov-report=term-missing
```

---

## 10. 数据流与业务逻辑

### 10.1 自动组卷完整流程

```
前端发起 POST /api/exams/generate
  │
  │  请求体: {
  │    "exam_id": "exam_001",
  │    "name": "期末考试",
  │    "config": {
  │      "单选": {"count": 5, "points": 2},
  │      "是非": {"count": 3, "points": 1}
  │    }
  │  }
  │
  ▼
路由处理函数 generate_exam()
  │
  ├── 1. 创建 ExamModel 实例，存入 exams 表
  │      db.session.add(exam)
  │      db.session.flush()  ← 确保 exam_id 生效
  │
  ├── 2. 遍历 config：
  │      ┌─ 题型="单选", count=5
  │      │   查询: SELECT * FROM questions
  │      │         WHERE trim(question_type) = '单选'
  │      │         AND is_used = 0
  │      │         LIMIT 5
  │      │   结果: [q1, q2, q3, q4, q5]
  │      │
  │      │   对每个查到的题目:
  │      │     INSERT INTO exam_questions (exam_id, question_id, position)
  │      │     (注意: 不修改 is_used，仅建立关联)
  │      │
  │      └─ 题型="是非", count=3
  │          (同上逻辑)
  │
  ├── 3. db.session.commit()  ← 一次性提交所有更改
  │
  └── 4. 返回 exam.to_dict()  ← 包含所有已选题目
```

### 10.2 题目使用状态流转

```
                 ┌──────────┐
     创建题目 ──►│ is_used  │
                 │ = False  │
                 └────┬─────┘
                      │
               确认试卷 confirm
               (标记试卷中所有题目)
                      │
                      ▼
                 ┌──────────┐
                 │ is_used  │
                 │ = True   │
                 │ used_date│
                 │ = now    │
                 └────┬─────┘
                      │
          ┌───────────┴───────────┐
          │                       │
     撤销确认                批量释放
     revert               batch-release
          │                       │
          ▼                       ▼
                 ┌──────────┐
                 │ is_used  │
                 │ = False  │
                 │ used_date│
                 │ = None   │
                 └──────────┘

注意：自动组卷(generate)和题目替换(replace)
不会修改 is_used 状态，仅操作 exam_questions 关联表。
```

### 10.3 题目替换的原子性

替换操作涉及 2 个数据修改，在同一个事务中完成：

1. `DELETE FROM exam_questions WHERE exam_id=? AND question_id=old_id`
2. `INSERT INTO exam_questions (exam_id, question_id, position) VALUES (?, new_id, original_position)`

所有修改通过一次 `db.session.commit()` 提交，保证数据一致性。替换不修改题目的 `is_used` 状态。

### 10.4 总分计算逻辑

```python
def calculate_total_score(self):
    total = 0
    config = json.loads(self.config)    # {"单选": {"count": 10, "points": 2}}
    for q in self.get_ordered_questions():
        question_config = config.get(q.question_type, {})
        points = question_config.get('points', 0)
        total += points                 # 每道题的分值从 config 中查找
    return total
```

注意：总分 = 每道题的分值之和（按实际题目数量），而非 config 中 count * points 的理论值。如果实际题目数少于 count，总分也会相应减少。

---

## 11. 部署与运维

### 11.1 开发环境启动

```bash
pip install flask flask-sqlalchemy python-docx pytest
python server.py
```

### 11.2 生产环境建议

当前使用 Flask 自带开发服务器，不适合生产环境。生产部署建议：

```bash
pip install gunicorn
gunicorn -w 4 -b 0.0.0.0:5000 "app.factory:create_app('production')"
```

### 11.3 数据库文件

- 位置：`exam_system.db`（项目根目录）
- 备份：直接复制此文件即可完整备份
- 重置：删除此文件后重启应用，将自动创建空数据库

### 11.4 从旧系统迁移

```bash
# 1. 确保 question_bank.json 在项目根目录
# 2. 运行迁移脚本（会清空现有数据库）
python migrate_json_to_db.py

# 3. 验证数据
python -c "
from app.factory import create_app
from app.db_models import db, QuestionModel, ExamModel
app = create_app('development')
with app.app_context():
    print(f'题目数量: {QuestionModel.query.count()}')
    print(f'试卷数量: {ExamModel.query.count()}')
"
```

### 11.5 目录权限要求

以下目录需要写入权限（应用会自动创建）：

| 目录 | 用途 |
|------|------|
| `exports/` | 导出的 JSON/CSV/Word 文件 |
| `temp/` | 临时上传文件和模板生成 |
| `uploads/` | 用户上传的文件 |

### 11.6 环境变量

| 变量 | 默认值 | 说明 |
|------|--------|------|
| `PORT` | `5000` | 服务器监听端口 |
| `FLASK_ENV` | `default` (即 development) | 配置环境名 |
| `SECRET_KEY` | `dev-secret-key-...` | Flask 密钥（生产环境务必修改） |
| `DATABASE_URL` | `sqlite:///exam_system.db` | 数据库连接 URI |
