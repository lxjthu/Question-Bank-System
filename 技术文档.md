# 林业经济学试题管理系统 — 技术文档

## 目录

1. [系统概述](#1-系统概述)
2. [架构设计](#2-架构设计)
3. [数据库设计](#3-数据库设计)
4. [ORM 模型详解](#4-orm-模型详解)
5. [API 路由详解](#5-api-路由详解)
6. [应用工厂与配置](#6-应用工厂与配置)
7. [工具函数模块](#7-工具函数模块)
8. [数据迁移](#8-数据迁移)
9. [测试体系](#9-测试体系)
10. [数据流与业务逻辑](#10-数据流与业务逻辑)
11. [部署与运维](#11-部署与运维)
12. [AI 智能出题模块（RAG）](#12-ai-智能出题模块rag)
    - 12.9 [幻灯片 KG 提取（slides_kg.py）](#129-幻灯片-kg-提取slides_kgpy)
    - 12.10 [知识图谱三级联动筛选](#1210-知识图谱三级联动筛选)
    - 12.11 [DeepSeek 直出模式（DS Mode）](#1211-deepseek-直出模式ds-mode)

---

## 1. 系统概述

### 1.1 项目背景

本系统为林业经济学（双语）课程设计的试题管理平台，解决以下核心需求：

- 管理多题型（单选、多选、是非、简答、计算、论述、材料等，支持自定义扩展）试题库
- 支持中英文双语题目
- 自动从未使用题目中组卷，避免跨年度重复出题
- 从 Word/TXT 模板文件批量导入题目
- 导出格式化的 Word 试卷文件

### 1.2 技术选型

| 层级 | 技术 | 选型理由 |
|------|------|---------|
| Web 框架 | Flask 3.x | 轻量、灵活，适合中小型项目 |
| ORM | Flask-SQLAlchemy | 声明式模型定义，自动建表 |
| 数据库 | SQLite | 零配置、单文件部署、适合单用户场景 |
| 文档处理 | python-docx | 读写 `.docx` 文件的成熟库 |
| 测试 | pytest | 功能丰富、fixture 机制优秀 |
| 前端 | 原生 JS SPA | 无构建工具依赖，`index.html` 单文件 |

### 1.3 从 JSON 到 SQLite 的演进

系统最初使用 `question_bank.json` 文件存储所有数据，通过 `QuestionBank` 单例在内存中操作。每次修改都全量重写 JSON 文件。这种方式存在以下问题：

| 问题 | 描述 |
|------|------|
| 并发安全 | 多请求同时写入会导致数据丢失 |
| 无事务保障 | 写入中断会导致数据损坏 |
| 性能瓶颈 | 大数据量时每次全量序列化/反序列化效率低 |
| 查询能力弱 | 搜索需遍历全部数据，无索引支持 |

迁移至 SQLite + SQLAlchemy 后，以上问题全部解决。同时保持了所有 API 接口和 JSON 响应格式不变，前端代码无需任何修改。

---

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────┐
│                    浏览器 (SPA)                       │
│              app/templates/index.html                │
│         （七标签页，含 AI 智能出题标签）               │
└──────────────────────┬──────────────────────────────┘
                       │ HTTP (fetch API)
                       ▼
┌─────────────────────────────────────────────────────┐
│                   Flask 应用层                        │
│                                                      │
│  server.py ──► factory.py ──► Blueprint (routes.py)  │
│                    │        ──► Blueprint (rag_routes.py)
│                    ▼                                  │
│              db.init_app()                            │
│              db.create_all()                          │
└───────────────┬──────────────────────┬───────────────┘
                │ SQLAlchemy ORM        │ sqlite3 直连
                ▼                      ▼
┌───────────────────────┐  ┌──────────────────────────┐
│     主数据库层         │  │      RAG 向量层            │
│                       │  │                          │
│  exam_system.db       │  │  rag_pipeline/kg.db      │
│  ├── question_types   │  │  ├── chunks 表            │
│  ├── questions        │  │  └── KG 表（章/概念/关系）  │
│  ├── exams            │  │                          │
│  └── exam_questions   │  │  qdrant_storage/         │
│                       │  │  （本地向量文件）           │
└───────────────────────┘  │                          │
                           │  bm25_index/bm25.pkl     │
                           └──────────────────────────┘
```

### 2.2 设计模式

- **应用工厂模式 (Application Factory)** — `create_app()` 函数根据配置名创建 Flask 实例，支持多环境切换
- **Blueprint** — 所有 API 路由注册在 `main` Blueprint 下
- **ORM 模式** — 通过 SQLAlchemy 模型类映射数据库表，不直接编写 SQL
- **多对多关联** — 试卷与题目通过 `exam_questions` 关联表建立关系，含 `position` 字段保持题序

### 2.3 文件职责说明

| 文件 | 职责 | 依赖 |
|------|------|------|
| `server.py` | 应用入口，创建并运行 Flask app | `factory.py` |
| `config.py` | 多环境配置类（开发/测试/生产） | 无 |
| `app/factory.py` | 应用工厂，初始化数据库、种子数据，注册两个 Blueprint | `db_models.py`, `routes.py`, `rag_routes.py`, `config.py` |
| `app/db_models.py` | SQLAlchemy ORM 模型定义（含 QuestionTypeModel） | `flask_sqlalchemy` |
| `app/routes.py` | 题库/试卷/题型等 REST API 路由和业务逻辑 | `db_models.py`, `utils.py` |
| `app/rag_routes.py` | RAG 知识库和 AI 出题 API（6 个端点） | `rag_pipeline`, `pptx_ocr`, `openai`, `python-dotenv` |
| `app/utils.py` | 工具函数（Word 导入/导出、文件验证） | `python-docx` |
| `app/models.py` | 旧版数据类定义（保留供参考） | 无 |
| `migrate_json_to_db.py` | JSON → SQLite 数据迁移脚本 | `factory.py`, `db_models.py` |
| `rag_pipeline/ingest.py` | 文档摄入流水线（分块→向量化→写 Qdrant+SQLite） | `chunker`, `embedder`, `vector_store`, `bm25_index` |
| `rag_pipeline/retriever.py` | 混合检索（稠密+BM25）→ RRF 融合 → 上下文扩展 | `vector_store`, `bm25_index`, `embedder` |
| `pptx_ocr/pipeline.py` | PPTX/PDF → Markdown OCR 流水线 | `api_client`, `pdf_splitter`, `converter` |

### 2.4 请求处理流程

```
客户端请求 ──► Flask 路由匹配 ──► 路由处理函数
                                      │
                                      ├── 解析请求参数/JSON body
                                      ├── SQLAlchemy 查询/修改
                                      ├── db.session.commit()
                                      └── 返回 JSON 响应
```

---

## 3. 数据库设计

### 3.1 ER 图

```
┌──────────────────────┐       ┌──────────────────────┐
│   question_types     │       │        exams         │
├──────────────────────┤       ├──────────────────────┤
│ PK id       (Auto)   │       │ PK exam_id      (64) │
│    name        (64)  │       │    name         (256)│
│    label       (64)  │       │    config      (Text)│
│    has_options (Bool) │       │    created_at   (DT) │
│    is_builtin  (Bool) │       │    updated_at   (DT) │
│    created_at   (DT) │       └──────────┬───────────┘
└──────────────────────┘                  │
                                          │
┌──────────────────────┐       ┌──────────┴───────────┐
│      questions       │       │   exam_questions      │
├──────────────────────┤       ├──────────────────────┤
│ PK question_id  (64) │◄──────┤ PK,FK question_id    │
│    question_type (32)│       │ PK,FK exam_id        │
│    content     (Text)│       │    position     (Int) │
│    options     (Text)│       └──────────────────────┘
│    answer      (Text)│
│    reference_answer  │
│    explanation (Text)│
│    content_en  (Text)│  ← 英文题目
│    options_en  (Text)│  ← 英文选项JSON
│    knowledge_point   │  ← 知识点
│    tags       (512)  │  ← 标签
│    difficulty  (32)  │  ← 难度
│    language     (10) │
│    metadata_json     │
│    is_used    (Bool) │
│    used_date    (DT) │
│    created_at   (DT) │
│    updated_at   (DT) │
└──────────────────────┘
```

### 3.2 表结构详解

#### `question_types` 表 — 题型

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `id` | `Integer` | **PK**, 自增 | 题型唯一标识 |
| `name` | `String(64)` | UNIQUE, NOT NULL | 题型标识名（如 `单选`、`简答>计算`） |
| `label` | `String(64)` | NOT NULL | 题型显示名（如 `单选题`、`计算题`） |
| `has_options` | `Boolean` | 默认 `False` | 是否为选择题（有选项） |
| `is_builtin` | `Boolean` | 默认 `False` | 是否为内置题型（不可删除） |
| `created_at` | `DateTime` | — | 创建时间 |

**内置题型（7 个）：** 系统首次启动时自动种子插入

| name | label | has_options |
|------|-------|-------------|
| 单选 | 单选题 | `True` |
| 多选 | 多选题 | `True` |
| 是非 | 是非题 | `True` |
| 简答 | 简答题 | `False` |
| 简答>计算 | 计算题 | `False` |
| 简答>论述 | 论述题 | `False` |
| 简答>材料分析 | 材料分析题 | `False` |

#### `questions` 表 — 题目

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `question_id` | `String(64)` | **PK** | 题目唯一标识（如 `q_20260112_130149_0`） |
| `question_type` | `String(32)` | NOT NULL, INDEX | 题型（单选/多选/是非/简答/计算/论述/材料） |
| `content` | `Text` | NOT NULL | 题目内容 |
| `options` | `Text` | 默认 `'[]'` | 选项列表，JSON 字符串（如 `'["A选项","B选项"]'`） |
| `answer` | `Text` | 可为 NULL | 标准答案（选择题为字母如 `"A"`/`"ABD"`） |
| `reference_answer` | `Text` | 可为 NULL | 参考答案（简答/论述题使用） |
| `explanation` | `Text` | 可为 NULL | 题目解析 |
| `content_en` | `Text` | 可为 NULL | 英文题目内容 |
| `options_en` | `Text` | 可为 NULL | 英文选项，JSON 字符串（如 `'["Option A","Option B"]'`） |
| `knowledge_point` | `String(256)` | 可为 NULL | 知识点（如"林业经济基础"） |
| `tags` | `String(512)` | 可为 NULL | 标签，逗号分隔（如 `"基础,概念,林业"`） |
| `difficulty` | `String(32)` | 可为 NULL | 难度等级（`easy`/`medium`/`hard`） |
| `language` | `String(10)` | 默认 `'zh'`, INDEX | 语言标记（`zh`/`en`/`both`），提供 `content_en` 时自动设为 `both` |
| `metadata_json` | `Text` | 默认 `'{}'` | 扩展元数据，JSON 字符串 |
| `is_used` | `Boolean` | 默认 `False`, INDEX | 是否已在试卷中使用 |
| `used_date` | `DateTime` | 可为 NULL | 使用日期 |
| `created_at` | `DateTime` | — | 创建时间 |
| `updated_at` | `DateTime` | — | 最后更新时间 |

**索引说明：** 在 `question_type`、`language`、`is_used` 三个字段上建有索引，用于加速按题型筛选、按语言过滤和查找未使用题目的查询。

**JSON 存储新增字段：** `options_en` 与 `options` 格式相同，存储英文选项的 JSON 数组。在 `to_dict()` 中自动反序列化为 list。

#### `exams` 表 — 试卷

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `exam_id` | `String(64)` | **PK** | 试卷唯一标识 |
| `name` | `String(256)` | NOT NULL | 试卷名称 |
| `config` | `Text` | 默认 `'{}'` | 组卷配置，JSON 字符串 |
| `created_at` | `DateTime` | — | 创建时间 |
| `updated_at` | `DateTime` | — | 最后更新时间 |

**config 字段格式示例：**

```json
{
  "单选": {"count": 10, "points": 2},
  "是非": {"count": 5, "points": 1},
  "简答": {"count": 3, "points": 10}
}
```

含义：10 道单选题每题 2 分，5 道是非题每题 1 分，3 道简答题每题 10 分，总分 55 分。

#### `exam_questions` 表 — 试卷-题目关联

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `exam_id` | `String(64)` | **PK**, FK → `exams.exam_id` | 试卷 ID |
| `question_id` | `String(64)` | **PK**, FK → `questions.question_id` | 题目 ID |
| `position` | `Integer` | — | 题目在试卷中的顺序（0 起始） |

复合主键 `(exam_id, question_id)` 确保同一题目不会在同一试卷中重复出现。`position` 字段确保题目按添加顺序排列。

### 3.3 JSON 存储字段设计决策

SQLite 没有原生 JSON 类型，以下字段使用 `Text` 类型存储 JSON 字符串：

| 字段 | 存储示例 | 读取时处理 |
|------|---------|-----------|
| `options` | `'["选项A","选项B","选项C","选项D"]'` | `json.loads()` → `list` |
| `options_en` | `'["Option A","Option B","Option C","Option D"]'` | `json.loads()` → `list`（为 NULL 时返回 `[]`） |
| `metadata_json` | `'{"source":"textbook","chapter":3}'` | `json.loads()` → `dict` |
| `config` | `'{"单选":{"count":10,"points":2}}'` | `json.loads()` → `dict` |

写入时使用 `json.dumps(data, ensure_ascii=False)` 保证中文字符正确存储。

---

## 4. ORM 模型详解

文件位置：`app/db_models.py`

### 4.1 QuestionTypeModel

```python
class QuestionTypeModel(db.Model):
    __tablename__ = 'question_types'
    id          = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name        = db.Column(db.String(64), unique=True, nullable=False)
    label       = db.Column(db.String(64), nullable=False)
    has_options = db.Column(db.Boolean, default=False)
    is_builtin  = db.Column(db.Boolean, default=False)
    created_at  = db.Column(db.DateTime, default=datetime.now)
```

**关键方法：**

- `to_dict()` — 将模型转换为 dict，包含所有字段。时间字段转为 ISO 格式字符串。

**设计说明：** `name` 字段设为 UNIQUE，确保题型标识唯一。`is_builtin` 标记内置题型，API 层禁止删除 `is_builtin=True` 的记录。`has_options` 用于前端判断添加题目时是否显示选项输入框以及模板生成时选择不同的格式。

### 4.2 QuestionModel

```python
class QuestionModel(db.Model):
    __tablename__ = 'questions'
    question_id    = db.Column(db.String(64), primary_key=True)
    question_type  = db.Column(db.String(32), nullable=False, index=True)
    content        = db.Column(db.Text, nullable=False)
    options        = db.Column(db.Text, default='[]')
    answer         = db.Column(db.Text)
    reference_answer = db.Column(db.Text)
    explanation    = db.Column(db.Text)
    content_en     = db.Column(db.Text, nullable=True)       # 英文题目
    options_en     = db.Column(db.Text, nullable=True)       # 英文选项 JSON
    knowledge_point = db.Column(db.String(256), nullable=True)
    tags           = db.Column(db.String(512), nullable=True) # 逗号分隔
    difficulty     = db.Column(db.String(32), nullable=True)  # easy/medium/hard
    language       = db.Column(db.String(10), default='zh', index=True)
    metadata_json  = db.Column(db.Text, default='{}')
    is_used        = db.Column(db.Boolean, default=False, index=True)
    used_date      = db.Column(db.DateTime)
    created_at     = db.Column(db.DateTime)
    updated_at     = db.Column(db.DateTime)
```

**关键方法：**

- `to_dict()` — 将模型转换为 dict，自动反序列化 JSON 字段（`options` → list，`options_en` → list，`metadata_json` → dict），时间字段转为 ISO 格式字符串。返回值直接用于 API JSON 响应。

### 4.3 ExamModel

```python
class ExamModel(db.Model):
    __tablename__ = 'exams'
    exam_id    = db.Column(db.String(64), primary_key=True)
    name       = db.Column(db.String(256), nullable=False)
    config     = db.Column(db.Text, default='{}')
    created_at = db.Column(db.DateTime)
    updated_at = db.Column(db.DateTime)

    questions = db.relationship('QuestionModel', secondary=exam_questions,
                    backref=db.backref('exams', lazy='dynamic'), lazy='dynamic')
```

**关键方法：**

| 方法 | 说明 |
|------|------|
| `to_dict()` | 转换为 dict，包含按 `position` 排序的题目列表 |
| `get_ordered_questions()` | 返回按 `position` 排序的 `QuestionModel` 列表 |
| `calculate_total_score()` | 根据 `config` 中每种题型的 `points` 值和实际题目数量计算总分 |

**`to_dict()` 中的排序查询：**

```python
ordered_questions = db.session.query(QuestionModel).join(
    exam_questions,
    QuestionModel.question_id == exam_questions.c.question_id
).filter(
    exam_questions.c.exam_id == self.exam_id
).order_by(exam_questions.c.position).all()
```

这个查询通过 JOIN `exam_questions` 关联表，按 `position` 字段升序排列，确保题目顺序与添加顺序一致。

### 4.4 exam_questions 关联表

```python
exam_questions = db.Table('exam_questions',
    db.Column('exam_id', db.String(64), db.ForeignKey('exams.exam_id'), primary_key=True),
    db.Column('question_id', db.String(64), db.ForeignKey('questions.question_id'), primary_key=True),
    db.Column('position', db.Integer)
)
```

这是 SQLAlchemy 的 `Table` 对象（非 ORM 模型），用于定义多对多关系。直接通过 `db.session.execute()` 操作。

---

## 5. API 路由详解

文件位置：`app/routes.py`

所有路由注册在 `main` Blueprint 下，请求和响应均为 JSON 格式（文件下载除外）。

### 5.1 题目管理 API

#### `GET /api/questions` — 获取/搜索题目

**查询参数：**

| 参数 | 类型 | 说明 |
|------|------|------|
| `keyword` | string | 按题目内容模糊搜索 |
| `type` | string | 按题型精确过滤（如 `单选`） |
| `language` | string | 按语言精确过滤（`zh`/`en`/`both`） |
| `difficulty` | string | 按难度精确过滤（`easy`/`medium`/`hard`） |
| `knowledge_point` | string | 按知识点模糊搜索 |
| `is_used` | string | 按使用状态过滤（`1` 已使用、`0` 未使用） |

六个参数可组合使用，均为可选。不传参数则返回全部题目。

**实现：** 使用 SQLAlchemy 链式查询构建动态过滤条件：

```python
query = QuestionModel.query
if keyword:
    query = query.filter(QuestionModel.content.contains(keyword))
if question_type:
    query = query.filter_by(question_type=question_type)
if language:
    query = query.filter_by(language=language)
if difficulty:
    query = query.filter_by(difficulty=difficulty)
if knowledge_point:
    query = query.filter(QuestionModel.knowledge_point.contains(knowledge_point))
if is_used == '1':
    query = query.filter_by(is_used=True)
elif is_used == '0':
    query = query.filter_by(is_used=False)
```

**响应示例：**

```json
[
  {
    "question_id": "q_20260112_130149_0",
    "question_type": "单选",
    "content": "Python是什么类型的语言？",
    "options": ["编译型", "解释型", "汇编型", "机器型"],
    "answer": "B",
    "reference_answer": null,
    "explanation": "Python是解释型语言",
    "content_en": "What type of language is Python?",
    "options_en": ["Compiled", "Interpreted", "Assembly", "Machine"],
    "knowledge_point": "编程语言基础",
    "tags": "基础,编程",
    "difficulty": "easy",
    "language": "both",
    "metadata": {},
    "is_used": false,
    "used_date": null,
    "created_at": "2026-01-12T13:01:49.058055",
    "updated_at": "2026-01-12T13:01:49.058055"
  }
]
```

#### `POST /api/questions` — 新增题目

**请求体 (JSON)：**

```json
{
  "question_id": "q_001",
  "question_type": "单选",
  "content": "题目内容",
  "options": ["选项A", "选项B", "选项C", "选项D"],
  "answer": "A",
  "reference_answer": null,
  "explanation": "解析内容",
  "language": "zh",
  "content_en": "Question content in English",
  "options_en": ["Option A", "Option B", "Option C", "Option D"],
  "knowledge_point": "知识点名称",
  "tags": "标签1,标签2",
  "difficulty": "medium",
  "metadata": {}
}
```

**业务逻辑：**
1. 从请求 JSON 中提取字段（含双语和元数据字段）
2. `options`、`options_en` 和 `metadata` 序列化为 JSON 字符串存入数据库
3. 自动设置 `created_at` 和 `updated_at` 为当前时间
4. **自动语言检测**：如果提供了 `content_en` 且 `language` 为 `zh`，自动升级为 `both`
5. 如果 `question_id` 重复，返回 400 错误（IntegrityError 捕获并回滚）

**响应：** `201 Created`，返回创建的题目对象

#### `GET /api/questions/<question_id>` — 获取单个题目

- 存在：返回 200 + 题目 JSON
- 不存在：返回 404 + `{"error": "Question not found"}`

#### `PUT /api/questions/<question_id>` — 更新题目

**请求体：** 仅需包含要更新的字段（部分更新）

```json
{
  "content": "更新后的内容",
  "answer": "B"
}
```

**业务逻辑：** 仅更新请求中包含的字段（含 `content_en`、`options_en`、`knowledge_point`、`tags`、`difficulty`），未提及的字段保持不变。如果更新后 `content_en` 有值且 `language` 仍为 `zh`，自动升级为 `both`。自动更新 `updated_at`。

#### `DELETE /api/questions/<question_id>` — 删除题目

返回 `{"message": "Question deleted successfully"}` 或 404。

#### `POST /api/questions/import` — 文件导入

**请求：** `multipart/form-data`，字段名 `file`

**支持的文件类型：**

| 类型 | 处理方式 |
|------|---------|
| `.txt` | 直接调用 `parse_question_template()` 解析 |
| `.docx` | 先调用 `word_to_csv_converter` 转为 CSV，再解析 |

**业务逻辑：**
1. 验证文件存在性和类型
2. 保存到 `temp/` 临时目录
3. 解析题目数据
4. 使用 `db.session.add_all()` 批量插入，一次 `commit()`（而非逐条提交）
5. 清理临时文件
6. 出错时 `db.session.rollback()` 回滚事务

**响应：** `{"message": "Questions imported successfully", "count": 15}`

#### `POST /api/questions/batch-delete` — 批量删除题目

**请求体 (JSON)：**

```json
{
  "question_ids": ["q_001", "q_002", "q_003"]
}
```

**业务逻辑：**
1. 验证 `question_ids` 列表非空（空列表返回 400）
2. 先删除 `exam_questions` 关联表中涉及这些题目的所有记录
3. 再删除 `questions` 表中存在的对应记录
4. 不存在的 ID 静默跳过，不报错

**响应：** `{"deleted_count": 2}` — 返回实际删除的题目数量

#### `POST /api/questions/batch-update-type` — 批量修改题型

**请求体 (JSON)：**

```json
{
  "question_ids": ["q_001", "q_002", "q_003"],
  "question_type": "多选"
}
```

**业务逻辑：**
1. 验证 `question_ids` 列表和 `question_type` 均非空
2. 验证目标题型在 `question_types` 表中存在
3. 使用 `QuestionModel.query.filter(...).update()` 批量更新，一次性提交
4. 返回实际更新的数量

**响应：** `{"message": "3 questions updated to \"多选\"", "updated_count": 3}`

#### `POST /api/questions/batch-release` — 批量释放题目

**请求体 (JSON)：**

```json
{
  "question_ids": ["q_001", "q_002", "q_003"]
}
```

**业务逻辑：**
1. 验证 `question_ids` 列表非空（空列表返回 400）
2. 遍历 ID 列表，将 `is_used=True` 的题目标记为 `is_used=False`，清除 `used_date`
3. 不存在的 ID 或已经为未使用状态的题目静默跳过
4. 返回实际释放的数量

**响应：** `{"message": "2 questions released", "released_count": 2}`

#### `GET /api/questions/export` — 导出题库

**查询参数：** `format=json`（默认）或 `format=csv`

**业务逻辑：**
1. 查询全部题目
2. 生成带时间戳的文件名
3. 写入 `exports/` 目录
4. 返回文件下载

### 5.2 试卷管理 API

#### `POST /api/exams` — 创建试卷

**请求体：**

```json
{
  "exam_id": "exam_2026_final",
  "name": "2026年期末考试",
  "config": {
    "单选": {"count": 10, "points": 2},
    "是非": {"count": 5, "points": 1},
    "简答": {"count": 3, "points": 10}
  }
}
```

**注意：** `exam_id` 为可选字段。如果未提供或为空，系统使用 `uuid.uuid4()` 自动生成（格式：`exam_xxxxxxxx`）。

#### `POST /api/exams/generate` — 自动组卷

这是系统最核心的业务逻辑。

**请求体：** 同创建试卷（`exam_id` 同样可省略，自动生成）

**业务逻辑：**

```
遍历 config 中的每种题型:
    1. 查询该题型中 is_used=False 的未使用题目
    2. 使用 db.func.trim() 处理题型名称的空格差异
    3. 取前 count 道题目
    4. 在 exam_questions 关联表中插入记录，分配递增的 position
最终一次性 commit() 提交所有更改

注意：组卷时不会标记题目为已使用（is_used 不变），
只有通过 confirm 确认试卷后才会标记为已使用。
```

**关键 SQL 查询：**

```python
QuestionModel.query.filter(
    db.func.trim(QuestionModel.question_type) == question_type.strip(),
    QuestionModel.is_used == False
).limit(count).all()
```

`db.func.trim()` 处理了题型名称前后可能存在的空格，确保 ` 单选 ` 和 `单选` 能匹配。

**题目不足时的行为：** 不报错，有多少选多少。例如请求 10 道单选题但只有 3 道未使用，则试卷中只包含 3 道。

#### `POST /api/exams/<id>/add_question` — 添加题目到试卷

**请求体：** `{"question_id": "q_001"}`

**业务逻辑：**
1. 验证试卷和题目都存在
2. 查询当前最大 `position` 值
3. 在关联表中插入新记录，`position = max_position + 1`

#### `DELETE /api/exams/<id>/remove_question/<qid>` — 从试卷移除题目

直接删除关联表中的对应记录。

#### `POST /api/exams/<id>/replace_question` — 替换题目

**请求体：**

```json
{
  "old_question_id": "q_001",
  "new_question_id": "q_002"
}
```

**业务逻辑：**
1. 验证旧题目在试卷中存在（通过 `exam_questions` 查询）
2. 验证新题目存在
3. 验证新旧题目类型相同（不同类型返回 400）
4. 关联表中删除旧记录、插入新记录，保持相同的 `position`

**注意：** 替换操作不会修改任何题目的 `is_used` 状态。使用状态仅由确认（confirm）和撤销确认（revert）管理。

#### `POST /api/exams/<id>/confirm` — 确认试卷

将试卷中所有题目标记为 `is_used=True`。用于最终定稿后锁定题目。

#### `POST /api/exams/<id>/revert_confirmation` — 撤销确认

将试卷中所有题目标记为 `is_used=False`，`used_date=None`。

#### `GET /api/exams/<id>/export` — 导出 Word 试卷

**查询参数：**

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `mode` | string | `zh` | 语言模式：`zh`（纯中文）、`en`（纯英文）、`both`（中英对照） |
| `show_answer` | string | `1` | 是否包含答案：`1`（含答案/解析）、`0`（仅题目） |

调用 `utils.export_exam_to_word(exam, filepath, mode, show_answer)` 生成 `.docx` 文件并返回下载。

#### `DELETE /api/exams/<id>` — 删除试卷

**业务逻辑：** 先删除 `exam_questions` 关联表中该试卷的所有记录，再删除试卷本体。注意：不会删除题目本身，也不会改变题目的 `is_used` 状态。

### 5.3 题型管理 API

#### `GET /api/question-types` — 获取所有题型

返回按 `id` 升序排列的所有题型列表（含内置和自定义）。

**响应示例：**

```json
[
  {"id": 1, "name": "单选", "label": "单选题", "has_options": true, "is_builtin": true, "created_at": "2026-01-12T10:00:00"},
  {"id": 8, "name": "简答>案例", "label": "案例分析题", "has_options": false, "is_builtin": false, "created_at": "2026-02-13T14:30:00"}
]
```

#### `POST /api/question-types` — 创建自定义题型

**请求体：**

```json
{
  "name": "简答>案例",
  "label": "案例分析题",
  "has_options": false
}
```

**校验规则：**
- `name` 不能为空
- `name` 不能与已有题型重复（返回 400 + `"already exists"` 错误）

**响应：** `201 Created`，返回创建的题型对象（`is_builtin` 自动设为 `false`）

#### `PUT /api/question-types/<id>` — 更新题型

支持部分更新，可修改 `name`、`label`、`has_options`。如果修改 `name`，需保证唯一性。

#### `DELETE /api/question-types/<id>` — 删除题型

**校验规则：**
- 不存在的 ID 返回 404
- 内置题型（`is_builtin=True`）不可删除（返回 400 + `"built-in"` 错误）
- 有题目引用该题型时不可删除（返回 400 + `"questions use this type"` 错误）

---

## 6. 应用工厂与配置

### 6.1 应用工厂

文件位置：`app/factory.py`

```python
def create_app(config_name=None):
    if config_name is None:
        config_name = os.environ.get('FLASK_ENV', 'default')

    app = Flask(__name__)
    app.config.from_object(config[config_name])

    # 初始化数据库
    db.init_app(app)
    with app.app_context():
        db.create_all()          # 自动创建不存在的表
        _seed_question_types()   # 种子数据：内置题型

    # 注册 Blueprint
    app.register_blueprint(bp)

    return app
```

**`_seed_question_types()` 种子函数：**

当 `question_types` 表为空时，自动插入 7 个内置题型（单选/多选/是非/简答/简答>计算/简答>论述/简答>材料分析）。已有数据时跳过，保证幂等性。

**初始化顺序：**
1. 创建 Flask 实例
2. 加载配置
3. `db.init_app(app)` — 将 SQLAlchemy 绑定到 Flask 应用
4. `db.create_all()` — 根据模型定义自动创建数据库表（幂等操作，已存在的表不会重建）
5. `_seed_question_types()` — 检查并插入内置题型种子数据
6. 注册 Blueprint

### 6.2 配置体系

文件位置：`config.py`

```python
class Config:                      # 基础配置
    SECRET_KEY = 'dev-secret-key-change-in-production'
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024   # 16MB
    SQLALCHEMY_DATABASE_URI = 'sqlite:///exam_system.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False

class DevelopmentConfig(Config):   # 开发环境
    DEBUG = True

class TestingConfig(Config):       # 测试环境
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite://'  # 内存数据库

class ProductionConfig(Config):    # 生产环境
    DEBUG = False
```

**测试环境使用内存数据库（`sqlite://`）：**
- 每次测试创建全新的数据库
- 测试结束自动销毁
- 完全隔离，不影响磁盘上的 `exam_system.db`
- 运行速度极快（无磁盘 I/O）

---

## 7. 工具函数模块

文件位置：`app/utils.py`

### 7.1 `allowed_file(filename)`

验证上传文件扩展名是否在允许列表中。

允许的扩展名：`txt`, `pdf`, `png`, `jpg`, `jpeg`, `gif`, `doc`, `docx`, `csv`

### 7.2 `generate_word_template()`

**动态**生成题库导入模板的 `.docx` 文件。从数据库查询所有已注册题型（含自定义题型），根据 `has_options` 字段生成对应格式的示例段落：
- 选择题（`has_options=True`）：生成带 `[A][B][C][D]` 中文选项和 `[A_en][B_en][C_en][D_en]` 英文选项的示例
- 非选择题（`has_options=False`）：生成带 `<参考答案>...</参考答案>` 的示例
- 所有示例的 `<解析>` 区段中包含元数据行示例：`知识点:`、`标签:`、`英文题目:`、`难度:`

返回值：模板文件路径（存放在 `temp/question_template.docx`）

### 7.3 `export_exam_to_word(exam, filepath, mode='zh', show_answer=True)`

将 `ExamModel` 实例导出为格式化的 Word 文档。

**参数：**

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `exam` | ExamModel | — | 试卷 ORM 实例 |
| `filepath` | str | — | 输出文件路径 |
| `mode` | str | `'zh'` | 语言模式：`zh`（纯中文）、`en`（纯英文）、`both`（中英对照） |
| `show_answer` | bool | `True` | 是否包含答案、参考答案和解析 |

**文档结构：**
1. 试卷标题（居中）
2. 考试信息（名称、生成时间、总分）
3. 按题型分组的题目列表
   - 每组一个一级标题
   - 题目内容加粗
   - 选择题显示选项（A/B/C/D）
   - `mode='en'` 时优先使用英文内容，不存在则回退到中文
   - `mode='both'` 时中英对照显示（选项用 `/` 分隔）
   - `show_answer=True` 时显示答案、参考答案、解析

**选项处理：** ORM 模型的选项需要从 JSON 字符串反序列化：

```python
options_zh = json.loads(question.options) if question.options else []
options_en = json.loads(question.options_en) if question.options_en else []
```

### 7.4 `parse_question_template(content)`

解析文本格式的题目模板，返回题目字典列表。

**支持的格式标记：**

| 标记 | 说明 |
|------|------|
| `[题型名]` | 题型标识（通用匹配，支持任意已注册题型） |
| `[A]`、`[B]`、`[C]`、`[D]` | 答案标识（紧跟题型后） |
| `[A]选项内容` | 中文选项行 |
| `[A_en]选项内容` | 英文选项行（紧跟中文选项后） |
| `<解析>...</解析>` | 解析内容（可选） |
| `<参考答案>...</参考答案>` | 参考答案（可选，注意闭合标签用 `</参考答案>`） |
| `（中文）`/`（英文）` | 双语标记（可选） |
| `[简答>论述]` | 题型子类型（`>` 分隔） |

**解析区段内支持的元数据行：**

| 格式 | 说明 | 映射字段 |
|------|------|---------|
| `知识点:xxx` | 知识点标注 | `knowledge_point` |
| `标签:xxx,yyy` | 逗号分隔标签 | `tags` |
| `英文题目:xxx` | 英文题目内容 | `content_en` |
| `难度:easy\|medium\|hard` | 难度等级 | `difficulty` |

这些元数据行会从解析内容中分离出来，不会包含在最终的 `explanation` 字段中。

---

## 8. 数据迁移

文件位置：`migrate_json_to_db.py`

### 8.1 迁移流程

```
读取 question_bank.json
    │
    ▼
去重题目 (按 question_id，保留最后出现的)
    │
    ▼
写入 questions 表
    │
    ▼
去重试卷 (按 exam_id，保留最后出现的)
    │
    ▼
写入 exams 表 + exam_questions 关联
    │
    ▼
db.session.commit() 一次性提交
```

### 8.2 去重策略

旧版 JSON 数据中存在以下重复问题：

| 重复类型 | 原因 | 处理方式 |
|---------|------|---------|
| 题目 ID 重复 | 旧系统未做唯一性检查 | 保留最后出现的记录 |
| 试卷 ID 重复 | 同上 | 保留最后出现的记录 |
| 试卷内题目 ID 重复 | 题目被多次添加到同一试卷 | 跳过已存在的关联 |
| 试卷引用不存在的题目 | 题目被删除后试卷未更新 | 跳过不存在的题目 |

**实现代码：**

```python
# 题目去重
question_map = {}
for q in data.get('questions', []):
    question_map[q['question_id']] = q  # 后出现的覆盖前面的

# 试卷内题目去重
seen_exam_qids = set()
for q_data in e.get('questions', []):
    qid = q_data['question_id']
    if qid in question_map and qid not in seen_exam_qids:
        seen_exam_qids.add(qid)
        # 插入关联记录...
```

### 8.3 运行方式

```bash
python migrate_json_to_db.py
```

输出示例：`迁移完成：57 道题目（原始 69 条，去重后），16 份试卷`

**注意：** 脚本执行 `db.drop_all()` + `db.create_all()`，会清空现有数据库后重建。适合一次性迁移，不适合增量同步。

---

## 9. 测试体系

### 9.1 测试架构

```
tests/
├── conftest.py             # 共享 fixtures 和辅助函数
├── test_models.py          # ORM 模型单元测试
├── test_question_api.py    # 题库 API 集成测试
├── test_exam_api.py        # 试卷 API 集成测试
├── test_business_logic.py  # 业务逻辑测试
├── test_edge_cases.py      # 边界情况测试
├── test_question_types.py  # 题型管理 API 测试
├── test_batch_delete.py    # 批量删除 API 测试
└── test_usage_management.py # 使用管理 API 测试
```

### 9.2 Fixtures 设计

定义在 `tests/conftest.py`：

| Fixture | 作用域 | 说明 |
|---------|--------|------|
| `app` | function | 创建测试 Flask 应用（内存 SQLite），每个测试函数独立 |
| `client` | function | Flask 测试客户端 |
| `db` | function | 数据库 session |
| `sample_question_data` | function | 单选题样本 JSON 数据 |
| `sample_exam_data` | function | 试卷样本 JSON 数据 |

**辅助函数：**

| 函数 | 说明 |
|------|------|
| `create_question_in_db(db, ...)` | 直接向数据库插入题目，支持 `content_en`/`options_en`/`knowledge_point`/`tags`/`difficulty` 参数 |
| `create_exam_in_db(db, ...)` | 直接向数据库插入试卷（含关联），用于准备测试数据 |

**测试隔离机制：**

```python
@pytest.fixture
def app():
    app = create_app('testing')        # 使用内存数据库
    with app.app_context():
        _db.create_all()               # 创建表
        yield app
        _db.session.remove()           # 清理 session
        _db.drop_all()                 # 删除所有表
```

每个测试函数都获得全新的数据库，测试之间完全隔离。

### 9.3 测试用例清单

#### `test_models.py` — ORM 模型测试 (13 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestQuestionModel | `test_create_question_model` | 创建题目、字段赋值正确 |
| | `test_question_to_dict` | `to_dict()` 输出格式、options 反序列化 |
| | `test_question_options_json` | options 作为 JSON 存储和读取 |
| | `test_question_metadata_json` | metadata 作为 JSON 存储和读取 |
| | `test_question_is_used_default` | `is_used` 默认值为 `False` |
| | `test_question_timestamps` | 时间戳正确设置和序列化 |
| | `test_question_nullable_fields` | 可为 NULL 的字段正确处理 |
| TestExamModel | `test_create_exam_model` | 创建试卷、字段赋值正确 |
| | `test_exam_to_dict` | `to_dict()` 输出格式 |
| | `test_exam_question_relationship` | 多对多关系的添加和删除 |
| | `test_exam_config_json` | config 的 JSON 存储和读取 |
| | `test_exam_calculate_total_score` | 总分计算逻辑 |
| | `test_exam_get_ordered_questions` | 题目按 position 排序 |

#### `test_question_api.py` — 题库 API 测试 (22 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestAddQuestion | `test_add_question` | POST 返回 201，数据正确 |
| | `test_add_question_single_choice` | 单选题创建 |
| | `test_add_question_true_false` | 是非题创建 |
| | `test_add_question_essay` | 论述题创建 |
| | `test_add_question_calculation` | 计算题创建 |
| | `test_add_question_material` | 材料题创建 |
| TestGetQuestions | `test_get_questions_empty` | 空库返回空列表 |
| | `test_get_questions_list` | 返回正确列表 |
| | `test_get_question_by_id` | 按 ID 获取 |
| | `test_get_question_not_found` | 404 处理 |
| TestUpdateQuestion | `test_update_question` | PUT 修改内容 |
| | `test_update_question_not_found` | 404 处理 |
| TestDeleteQuestion | `test_delete_question` | DELETE 后再查为 404 |
| | `test_delete_question_not_found` | 404 处理 |
| TestSearchQuestions | `test_search_by_keyword` | 关键词搜索 |
| | `test_search_by_type` | 题型过滤 |
| | `test_search_by_language` | 语言过滤 |
| | `test_search_combined` | 多条件组合 |
| | `test_search_no_results` | 无结果返回空列表 |
| TestImportExport | `test_import_txt_file` | TXT 文件导入 |
| | `test_import_no_file` | 无文件返回 400 |
| | `test_export_invalid_format` | 无效格式返回 400 |

#### `test_exam_api.py` — 试卷 API 测试 (20 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestCreateExam | `test_create_exam` | POST 返回 201 |
| | `test_get_exams_empty` | 空列表 |
| | `test_get_exams_list` | 正确列表 |
| TestGetExam | `test_get_exam_by_id` | 按 ID 获取 |
| | `test_get_exam_not_found` | 404 |
| TestUpdateExam | `test_update_exam` | 修改名称和配置 |
| TestDeleteExam | `test_delete_exam` | 删除试卷 |
| TestExamQuestionOperations | `test_add_question_to_exam` | 添加题目到试卷 |
| | `test_add_nonexistent_question_to_exam` | 添加不存在的题目返回 404 |
| | `test_remove_question_from_exam` | 移除题目 |
| TestGenerateExam | `test_generate_exam` | 自动组卷 |
| | `test_generate_exam_insufficient_questions` | 题目不足时的行为 |
| TestConfirmRevert | `test_confirm_exam` | 确认试卷 |
| | `test_confirm_marks_questions_used` | 确认后 `is_used=True` |
| | `test_revert_confirmation` | 撤销确认 |
| | `test_revert_marks_questions_unused` | 撤销后 `is_used=False` |
| TestReplaceQuestion | `test_replace_question` | 替换题目 |
| | `test_replace_question_wrong_type` | 不同类型返回 400 |
| TestExportExam | `test_export_exam_not_found` | 不存在返回 404 |
| | `test_export_exam_to_word` | Word 导出成功 |

#### `test_business_logic.py` — 业务逻辑测试 (10 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestUsageTracking | `test_unused_questions_filter` | 仅筛选未使用题目 |
| | `test_generate_selects_unused_only` | 组卷只选未使用题目 |
| | `test_generate_does_not_mark_used` | 组卷不标记已使用（仅确认时标记） |
| | `test_confirm_marks_then_generate_no_overlap` | 确认后再组卷不重复 |
| | `test_replace_does_not_change_used_flags` | 替换不改变使用状态 |
| TestBilingualSupport | `test_bilingual_question` | `language='both'` 双语题目 |
| | `test_question_type_whitespace_handling` | 题型空格处理 |
| TestTemplateAndExport | `test_template_download` | 模板下载 |
| | `test_word_export_content` | Word 导出内容 |
| | *(此类共 2 个测试)* | |

#### `test_edge_cases.py` — 边界情况测试 (9 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestInputValidation | `test_add_question_missing_fields` | 缺少字段处理 |
| | `test_add_question_empty_content` | 空内容处理 |
| TestSpecialContent | `test_question_special_characters` | 引号、换行、HTML 标签 |
| | `test_question_unicode_content` | 中英文混合 |
| | `test_very_long_content` | 超长内容（5000 字） |
| TestDuplicateHandling | `test_duplicate_question_id` | 重复 ID 返回错误 |
| TestEmptyExamOperations | `test_empty_exam_operations` | 空试卷的确认/撤销 |
| | `test_exam_with_no_config` | 无配置试卷 |
| TestDataIntegrity | `test_concurrent_data_integrity` | 快速连续操作的数据一致性 |
| TestIndexPage | `test_index_page` | 首页返回 HTML |

#### `test_question_types.py` — 题型管理 API 测试 (10 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestQuestionTypeCRUD | `test_get_question_types_returns_builtin` | 种子数据返回 7 个内置题型 |
| | `test_create_custom_type` | 创建自定义题型 |
| | `test_create_duplicate_name_fails` | 重复名称返回 400 |
| | `test_create_empty_name_fails` | 空名称返回 400 |
| | `test_update_question_type` | 更新题型标签 |
| | `test_update_duplicate_name_fails` | 更新为重复名称返回 400 |
| | `test_delete_custom_type` | 删除自定义题型 |
| | `test_delete_builtin_fails` | 删除内置题型返回 400 |
| | `test_delete_referenced_type_fails` | 删除有题目引用的题型返回 400 |
| | `test_delete_nonexistent_type` | 删除不存在的题型返回 404 |

#### `test_usage_management.py` — 使用管理 API 测试 (7 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestUsageManagement | `test_filter_used_questions` | `is_used=1` 过滤已使用题目 |
| | `test_filter_unused_questions` | `is_used=0` 过滤未使用题目 |
| | `test_batch_release_questions` | 批量释放标记 `is_used=False`、清除 `used_date` |
| | `test_batch_release_empty_list` | 空列表返回 400 |
| | `test_batch_release_already_unused` | 已未使用的题目 `released_count=0` |
| | `test_batch_release_partial` | 混合已使用/未使用/不存在的 ID |
| | `test_filter_used_combined_with_type` | `is_used` 与 `type` 组合过滤 |

#### `test_batch_delete.py` — 批量删除 API 测试 (5 个)

| 测试类 | 测试用例 | 验证内容 |
|--------|---------|---------|
| TestBatchDelete | `test_batch_delete_multiple_questions` | 批量删除多题，未删的仍存在 |
| | `test_batch_delete_empty_list` | 空列表返回 400 |
| | `test_batch_delete_cleans_exam_associations` | 删除后试卷关联自动清理 |
| | `test_batch_delete_partial_existing` | 部分存在的 ID，只删存在的 |
| | `test_batch_delete_all_nonexistent` | 全部不存在返回 deleted_count=0 |

### 9.4 运行测试

```bash
# 运行全部测试
python -m pytest tests/ -v

# 运行特定测试文件
python -m pytest tests/test_models.py -v

# 运行特定测试类
python -m pytest tests/test_exam_api.py::TestGenerateExam -v

# 运行特定测试用例
python -m pytest tests/test_business_logic.py::TestUsageTracking::test_generate_selects_unused_only -v

# 查看测试覆盖率（需安装 pytest-cov）
pip install pytest-cov
python -m pytest tests/ --cov=app --cov-report=term-missing
```

---

## 10. 数据流与业务逻辑

### 10.1 自动组卷完整流程

```
前端发起 POST /api/exams/generate
  │
  │  请求体: {
  │    "exam_id": "exam_001",
  │    "name": "期末考试",
  │    "config": {
  │      "单选": {"count": 5, "points": 2},
  │      "是非": {"count": 3, "points": 1}
  │    }
  │  }
  │
  ▼
路由处理函数 generate_exam()
  │
  ├── 1. 创建 ExamModel 实例，存入 exams 表
  │      db.session.add(exam)
  │      db.session.flush()  ← 确保 exam_id 生效
  │
  ├── 2. 遍历 config：
  │      ┌─ 题型="单选", count=5
  │      │   查询: SELECT * FROM questions
  │      │         WHERE trim(question_type) = '单选'
  │      │         AND is_used = 0
  │      │         LIMIT 5
  │      │   结果: [q1, q2, q3, q4, q5]
  │      │
  │      │   对每个查到的题目:
  │      │     INSERT INTO exam_questions (exam_id, question_id, position)
  │      │     (注意: 不修改 is_used，仅建立关联)
  │      │
  │      └─ 题型="是非", count=3
  │          (同上逻辑)
  │
  ├── 3. db.session.commit()  ← 一次性提交所有更改
  │
  └── 4. 返回 exam.to_dict()  ← 包含所有已选题目
```

### 10.2 题目使用状态流转

```
                 ┌──────────┐
     创建题目 ──►│ is_used  │
                 │ = False  │
                 └────┬─────┘
                      │
               确认试卷 confirm
               (标记试卷中所有题目)
                      │
                      ▼
                 ┌──────────┐
                 │ is_used  │
                 │ = True   │
                 │ used_date│
                 │ = now    │
                 └────┬─────┘
                      │
          ┌───────────┴───────────┐
          │                       │
     撤销确认                批量释放
     revert               batch-release
          │                       │
          ▼                       ▼
                 ┌──────────┐
                 │ is_used  │
                 │ = False  │
                 │ used_date│
                 │ = None   │
                 └──────────┘

注意：自动组卷(generate)和题目替换(replace)
不会修改 is_used 状态，仅操作 exam_questions 关联表。
```

### 10.3 题目替换的原子性

替换操作涉及 2 个数据修改，在同一个事务中完成：

1. `DELETE FROM exam_questions WHERE exam_id=? AND question_id=old_id`
2. `INSERT INTO exam_questions (exam_id, question_id, position) VALUES (?, new_id, original_position)`

所有修改通过一次 `db.session.commit()` 提交，保证数据一致性。替换不修改题目的 `is_used` 状态。

### 10.4 总分计算逻辑

```python
def calculate_total_score(self):
    total = 0
    config = json.loads(self.config)    # {"单选": {"count": 10, "points": 2}}
    for q in self.get_ordered_questions():
        question_config = config.get(q.question_type, {})
        points = question_config.get('points', 0)
        total += points                 # 每道题的分值从 config 中查找
    return total
```

注意：总分 = 每道题的分值之和（按实际题目数量），而非 config 中 count * points 的理论值。如果实际题目数少于 count，总分也会相应减少。

---

## 11. 部署与运维

### 11.1 开发环境启动

```bash
pip install flask flask-sqlalchemy python-docx pytest
python server.py
```

### 11.2 生产环境建议

当前使用 Flask 自带开发服务器，不适合生产环境。生产部署建议：

```bash
pip install gunicorn
gunicorn -w 4 -b 0.0.0.0:5000 "app.factory:create_app('production')"
```

### 11.3 数据库文件

- 位置：`exam_system.db`（项目根目录）
- 备份：直接复制此文件即可完整备份
- 重置：删除此文件后重启应用，将自动创建空数据库

### 11.4 从旧系统迁移

```bash
# 1. 确保 question_bank.json 在项目根目录
# 2. 运行迁移脚本（会清空现有数据库）
python migrate_json_to_db.py

# 3. 验证数据
python -c "
from app.factory import create_app
from app.db_models import db, QuestionModel, ExamModel
app = create_app('development')
with app.app_context():
    print(f'题目数量: {QuestionModel.query.count()}')
    print(f'试卷数量: {ExamModel.query.count()}')
"
```

### 11.5 目录权限要求

以下目录需要写入权限（应用会自动创建）：

| 目录 | 用途 |
|------|------|
| `exports/` | 导出的 JSON/CSV/Word 文件 |
| `temp/` | 临时上传文件和模板生成 |
| `uploads/` | 用户上传的文件 |
| `rag_uploads/` | RAG 知识库用户上传文档 |

### 11.6 环境变量

| 变量 | 默认值 | 说明 |
|------|--------|------|
| `PORT` | `5000` | 服务器监听端口 |
| `FLASK_ENV` | `default` (即 development) | 配置环境名 |
| `SECRET_KEY` | `dev-secret-key-...` | Flask 密钥（生产环境务必修改） |
| `DATABASE_URL` | `sqlite:///exam_system.db` | 数据库连接 URI |
| `DEEPSEEK_API_KEY` | — | DeepSeek API Key，用于 AI 智能出题；写入 `.env` 文件（见第 12 章） |

---

## 12. AI 智能出题模块（RAG）

### 12.1 模块概述

AI 智能出题是第 7 个标签页，将 RAG Pipeline 与 Flask 前端集成。用户可：

1. 上传课件/教材建立本地向量知识库
2. 按文档/章节/知识点筛选检索范围
3. 配置题型数量和出题语言
4. 一键调用 DeepSeek API 生成题目并导入题库

### 12.2 文件结构

```
app/rag_routes.py              ← Flask Blueprint（RAG 8 端点）
app/kg_routes.py               ← Flask Blueprint（知识图谱 3 端点）
rag_pipeline/
├── config.py                  ← 路径、模型名、检索参数
├── chunker.py                 ← 文档分块（教材章节/幻灯片页）
├── embedder.py                ← BGE-large-zh-v1.5 向量嵌入
├── vector_store.py            ← Qdrant 本地向量库
├── bm25_index.py              ← BM25 稀疏检索（rank_bm25 + jieba）
├── retriever.py               ← 混合检索 + RRF 融合
├── ingest.py                  ← 摄入流水线（写 Qdrant + SQLite）
├── db.py                      ← chunks 表 + KG 表（kg.db）
├── kg_extractor.py            ← DeepSeek KG 提取（教材 + 幻灯片共用）
├── slides_kg.py               ← 幻灯片 KG 流程（主题分组 + 提取）★新增
├── question_generator.py      ← 基于 KG 的题目生成
├── prompts.py                 ← KG 提取 + 题目生成 Prompt 模板
├── kg.db                      ← SQLite（chapters/concepts/relations + chunks）
├── qdrant_storage/            ← Qdrant 本地文件（向量索引）
└── bm25_index/bm25.pkl        ← BM25 序列化索引
pptx_ocr/
├── pipeline.py                ← process_pptx() + process_pdf()
├── api_client.py              ← Layout Parsing API 客户端
└── pdf_splitter.py            ← PDF 分 10 页 chunk 工具
rag_uploads/                   ← 用户上传文档（运行时自动创建）
```

### 12.3 API 端点

文件位置：`app/rag_routes.py`，Blueprint 名 `rag`，所有路由前缀 `/api/rag`。

| 方法 | 路径 | 说明 |
|------|------|------|
| `GET` | `/api/rag/docs` | 列出已摄入文档，查询 `kg.db` chunks 表，返回 `[{doc_id, source_type, chunk_count}]` |
| `GET` | `/api/rag/docs/<doc_id>/meta` | 获取文档章节名和节名，用于前端筛选 |
| `DELETE` | `/api/rag/docs/<doc_id>` | 删除向量库 + SQLite chunks + KG（chapters/concepts/relations） |
| `POST` | `/api/rag/ingest` | 上传并摄入文档（multipart `file` + `doc_type` + 可选 `subject_hint`）；PPTX/PDF 完成后自动触发 KG 提取 |
| `GET` | `/api/rag/tasks/<task_id>` | 轮询后台任务状态（running → KG 提取中... → done/error） |
| `POST` | `/api/rag/generate` | RAG 检索 + DeepSeek 出题 |
| `GET` | `/api/rag/config` | 读取 API 配置（PaddleOCR URL/Token、DeepSeek Key） |
| `PUT` | `/api/rag/config` | 保存 API 配置到 `.env` 文件 |

#### `/api/rag/ingest` 处理逻辑

```
上传文件
    │
    ├─ .md / .txt  ──► Ingestor.ingest_textbook() 或 ingest_slides()
    │
    ├─ .docx       ──► python-docx 提取段落文本 → 临时 .md → ingest_textbook()
    │
    └─ .pptx / .pdf ──► 后台线程:
                         ├─ .pdf: process_pdf() → result.md
                         ├─ .pptx: process_pptx() → result.md
                         ├─ Ingestor.ingest_slides() 或 ingest_textbook()
                         └─ （幻灯片）slides_kg.build_kg_for_slides()
                              ├─ detect_topics() 主题分组
                              ├─ 逐组 extract_kg_for_chapter()
                              └─ db.save_chapter(doc_id=...) + db.save_kg()
                         任务状态实时更新至 _ocr_tasks[task_id]
```

#### `/api/rag/generate` 处理逻辑

```
接收 {doc_ids, chapters, knowledge_points, prompt, question_list}
    │
    ├─ 1. 构建检索 queries（章节名 + 知识点名，最多 12 条）
    │
    ├─ 2. HybridRetriever.search() 混合检索（top_n=6/query）
    │      ├─ 稠密检索：BGE 向量 → Qdrant
    │      ├─ 稀疏检索：BM25
    │      └─ RRF 融合 → 上下文扩展 → 去重
    │
    ├─ 3. 累积 context 文本（上限 6000 字）
    │
    ├─ 4. 替换提示词占位符：
    │      prompt.replace('{context}', context)
    │            .replace('{question_list}', question_list)
    │
    ├─ 5. dotenv_values('.env') 读取 DEEPSEEK_API_KEY
    │      （直接读文件，不受系统环境变量干扰）
    │
    └─ 6. OpenAI SDK 调用 deepseek-chat
           model='deepseek-chat', max_tokens=8000, temperature=0.7
           返回 {success, content, stats: {chunks_used, context_chars}}
```

### 12.4 组件单例与懒加载

ML 组件（Embedder、VectorStore、BM25Index）很重（首次加载需下载 1.3 GB 模型），采用单例 + 懒加载策略：

```python
_lock = threading.Lock()
_ingestor = None    # 首次调用 ingest/delete 时初始化
_retriever = None   # 首次调用 generate 时初始化

def _get_ingestor():
    global _ingestor
    if _ingestor is not None:
        return _ingestor
    with _lock:
        if _ingestor is not None:
            return _ingestor
        from rag_pipeline.ingest import Ingestor
        _ingestor = Ingestor()   # 内部懒加载 Embedder/VectorStore/BM25
    return _ingestor
```

**优点：**
- Flask 启动时不加载任何 ML 组件，启动速度不受影响
- 未安装 RAG 依赖（`qdrant-client`、`sentence-transformers` 等）时，其他 API 正常工作；只有访问 `/api/rag/*` 才会触发 ImportError

**降级行为：**
- 若 RAG 组件加载失败（依赖缺失），`/api/rag/generate` 会捕获异常，改用空 context 继续调用 DeepSeek API 出题（不依赖本地知识库，但仍可生成题目）

### 12.5 API Key 读取机制

**问题：** `load_dotenv()` 默认不覆盖已有环境变量。Flask 进程启动时，系统环境变量中可能存在旧的 `DEEPSEEK_API_KEY`，导致 `.env` 文件中的正确 Key 被忽略。

**解决方案：** 改用 `dotenv_values()` 直接读取文件内容，完全绕过 `os.environ`：

```python
from dotenv import dotenv_values

env_vals = dotenv_values(_project_root() / '.env')   # 直接读文件
api_key = (
    env_vals.get('DEEPSEEK_API_KEY')     # 文件优先
    or env_vals.get('DEEPSEEK_TOKEN')
    or os.environ.get('DEEPSEEK_API_KEY', '')  # 兜底
)
```

**优先级：** `.env 文件` > 系统/进程环境变量

### 12.6 前端实现要点

文件位置：`app/templates/index.html`（第 7 个标签页，id="ai-generation"）

**布局：**
- 左列 260px（固定宽）：知识库管理（上传 + 文档列表）
- 右列 flex:1：出题配置（科目、文档选择、章节筛选、题型数量、出题语言）
- 下方全宽：提示词编辑器 + 一键出题按钮 + 结果区

**布局关键设计：** 出题语言和题型数量区域使用 `flex-shrink:0; width:90px`（语言）+ `flex:1; min-width:0`（题型表），**不使用 `.form-group` 类**（该类含 `min-width:280px` 会导致两列重叠）。

**提示词模板：** 3 个 JS 常量（`RAG_PROMPT_ZH`/`RAG_PROMPT_BILINGUAL`/`RAG_PROMPT_EN`），含 `{context}` 和 `{question_list}` 占位符（JS 模板字符串中 `{context}` 不以 `$` 开头，不会被求值，直接作为字面文本）。

**导入结果：**
```javascript
// 将 textarea 内容封装为 Blob 文件，复用 /api/questions/import 接口
const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
const file = new File([blob], 'ai_generated_questions.txt');
const fd = new FormData();
fd.append('file', file);
fetch('/api/questions/import', { method: 'POST', body: fd });
```

### 12.7 pptx_ocr/pipeline.py 新增函数

`process_pdf(pdf_path, output_dir, *, keep_temp, use_chart_recognition) → Path`

直接处理 PDF，跳过 PPTX→PDF 转换步骤，其余逻辑与 `process_pptx()` 第二阶段相同：

```
split_pdf(pdf_path, chunk_size=10)
    → 对每个 chunk: client.parse_file(chunk_path, file_type=0)
    → _save_results(pdf_path, results, output_dir)
    → 返回 result.md 路径
```

### 12.8 依赖说明

**RAG 功能依赖**（`rag_pipeline/requirements_rag.txt`）：

```
qdrant-client>=1.9          # 向量库
sentence-transformers>=3.0  # BGE 嵌入模型（约 1.3 GB）
rank_bm25>=0.2              # BM25 稀疏检索
jieba>=0.42                 # 中文分词
python-dotenv>=1.0          # .env 文件读取
openai>=1.0                 # DeepSeek API（兼容 OpenAI SDK）
```

> 注：`sentence-transformers` 首次运行时会从 HuggingFace（或镜像）下载 BGE-large-zh-v1.5 模型（约 1.3 GB）。也可提前下载到 `models/BAAI/bge-large-zh-v1.5/` 目录，embedder.py 会优先加载本地文件。

### 12.9 幻灯片 KG 提取（slides_kg.py）

#### 背景与动机

幻灯片 OCR 后文本碎片化（每页仅 30-100 字），RAG 切块按页分割无法识别跨页知识点，也无法形成结构化概念图。对于小规模幻灯片文档（< 5 万字），直接调用 DeepSeek 提取 KG 成本极低（~¥0.10/份），且语义质量远高于 chunk 检索。

#### 主题检测（`detect_topics()`）

```
OCR result.md
    │
    ├─ _parse_pages()  ← 按 "## Page N" 分割，清洗图片引用
    │
    ├─ 标题页判定（_is_title_page()，三级规则）：
    │   1. 去空格字符数 ≤ 30 且 ≤2行 且无子弹点 → 强判标题页（封面/章标）
    │   2. 字符数 ≤ 80 且首行精确匹配章节正则 → 标题页
    │   3. 其余 → 内容页
    │
    ├─ 若无标题页 → 每 15 页强制分组（兜底策略）
    │
    └─ 按标题页切组：
        ├─ 封面/前言（第一标题页前）→ 独立前言组
        └─ 每个标题页 → 新主题组（含后续内容页）
            过滤：有效字符 < 40 的组跳过（纯分隔幻灯片）
```

章节正则覆盖：`第X章/节/讲/部分`、`Chapter N`、`Unit N`（英文不区分大小写）。

#### `_make_chapter_id()` 防冲突设计

幻灯片 KG 章节 ID 用 SHA-256 哈希生成：

```python
raw = f"slides::{doc_id}::{topic_idx}"
h = int(hashlib.sha256(raw.encode()).hexdigest()[:12], 16)
chapter_id = (h % 90_000_000_000) + 10_000_000   # 范围 [10M, 90G]
```

教材章节 ID 为小整数（1-17），幻灯片 ID 偏移到 1000 万以上，完全无冲突风险。

#### `db.py` 扩展（向前兼容）

| 变更 | 说明 |
|------|------|
| `chapters` 表新增 `doc_id TEXT DEFAULT ''` | 教材已有章节 `doc_id=''`，幻灯片章节填真实 `doc_id` |
| `save_chapter(…, doc_id='')` | 新增关键字参数，默认空串保持向后兼容 |
| `delete_kg_by_doc(doc_id)` | 级联删除 relations → concepts → chapters |
| `get_chapters_by_doc(doc_id)` | 按文档查询章节列表 |
| `init_db()` 迁移 | `ALTER TABLE chapters ADD COLUMN doc_id TEXT DEFAULT ''`，用 `try/except` 保证幂等 |

#### `prompts.py` / `kg_extractor.py` 扩展

`kg_extraction_prompt(…, subject_hint='农业经济学')` — 动态替换专家角色描述：

```python
expert_role = f"{subject_hint}专家和教学内容分析专家"
# → "林业经济学专家和教学内容分析专家"（幻灯片时）
# → "农业经济学专家和教材分析专家"（教材时，默认值）
```

`subject_hint` 从文件名 stem 自动提取（`rag_routes.py` 中 `request.form.get('subject_hint', stem)`），也可由前端表单显式传入。

#### `kg_routes.py` 适配

幻灯片 KG 章节（`chapters.doc_id != ''`）在图谱页以 `kgch::{chapter_id}` 前缀节点呈现，并追加到 `ch_name_to_nid` 映射：

```python
for kc in kg_chapters_rows:
    if kc['doc_id']:   # 幻灯片 KG 章节
        kg_ch_nid = f"kgch::{kc['id']}"
        add_node({type: 'chapter', doc_id: kc['doc_id'], ...})
        links.append({source: f"doc::{kc['doc_id']}", target: kg_ch_nid, rel: 'structural'})
        ch_name_to_nid[kc['name']] = kg_ch_nid   # 概念可连到此章节节点
```

概念节点的 `doc_id` 优先取 `chapters.doc_id`（幻灯片），回退到 `ch_name_to_nid` 推断（教材），再兜底概念自身 `doc_id`。

---

### 12.10 知识图谱三级联动筛选

#### 问题背景

原有文档筛选（`_selectedDocs`）仅过滤有 `doc_id` 的节点。概念节点（`concept`）原无 `doc_id`，切换到仅显示"林业经济学"时，图谱中仍显示"农业经济学"的全部概念。

#### 修复：concept 节点加 `doc_id`

后端构建概念节点时，通过 `chapters.doc_id` 直接获取（不再通过 `ch_name_to_nid` 间接推断）。前端 `if (n.doc_id && !_selectedDocs.has(n.doc_id))` 即可正确过滤。

#### 三级筛选状态

```javascript
let _selectedDocs     = new Set();   // 文档 ID 集合
let _selectedChapters = new Set();   // "${doc_id}::${chapter_num}" 集合
let _selectedConcepts = new Set();   // concept 节点 ID 集合
```

切换触发逻辑：

```
文档切换
  → _selectedChapters = 所有当前文档下的章节（全选）
  → _selectedConcepts = 所有当前文档下的概念（全选）
  → renderChapterFilter() → renderConceptFilter() → renderGraph()

章节切换
  → _selectedConcepts = getAvailableConcepts()（按新章节集全选）
  → renderConceptFilter() → renderGraph()

知识点切换
  → renderGraph()（仅重绘图谱）
```

#### `getAvailableConcepts()` 修复前后对比

| 场景 | 修复前 | 修复后 |
|------|-------|-------|
| 幻灯片文档（无 chapter 节点，totalCh=0） | `size >= 0` 恒 true → 返回全部概念 | 先过滤 `doc_id`，totalCh=0 直接返回 docConcepts |
| 全不选章节（deselectAll） | 返回全部概念 | `_selectedChapters.size === 0` → 返回 [] |
| 部分选中章节 | 按 chapter_name 过滤 | 仍按 chapter_name 过滤，但先经 doc_id 初筛 |

#### 章节筛选徽章

章节面板标题显示 `X/N` 格式徽章（选中数/总数），`selected < total` 时显示，全选时自动隐藏。知识点面板同理。

---

### 12.11 DeepSeek 直出模式（DS Mode）

#### 设计动机

RAG 向量检索模式依赖 BGE-large-zh 嵌入模型（约 1.3 GB）和 Qdrant 向量库，对 GPU 显存和依赖安装有较高门槛。DeepSeek 直出模式（DS Mode）以纯 API 调用替代本地模型：

| 对比项 | DS 直出模式 | RAG 向量检索模式 |
|--------|------------|----------------|
| GPU 要求 | 无 | 推荐 ≥4 GB 显存 |
| 依赖大小 | 仅 openai / dotenv | +qdrant-client + sentence-transformers + BGE 模型（~1.3 GB）|
| 上下文来源 | DeepSeek 提炼的结构化知识图谱 | 向量相似度检索的原文 chunks |
| 知识质量 | 经过 DeepSeek 归纳整理，语义完整 | 原文片段，噪声较多 |
| API 消耗 | 多一次"提取"调用（每章 1 次） | 仅出题时调用 |

#### 整体架构概览

DS 直出模式（DeepSeek Straight-through Mode）是一套**不依赖向量库**的两阶段知识图谱出题系统，完整流程如下：

```
上传文档
    │
    ▼
【分片层】文档 → 章节列表
  · .md / .txt  →  正则按标题切分
  · .docx       →  Word Heading 样式 → Markdown → 正则切分
  · .pdf / .pptx →  PaddleOCR 异步 → result.md → 正则切分
    │
    ▼（存入 ds_chapters）
【提取层】章节 → 知识点（逐章调用 DeepSeek）
  · 超 8000 字截断
  · system: 教材分析专家
  · temperature=0.3，强制 JSON 输出
  · 提取 3~8 个知识点，含关系图谱
    │
    ▼（存入 ds_kps）
【生成层】知识点 → 题目（一次 DeepSeek 调用）
  · 按章节组装上下文，累计 7000 字封顶
  · temperature=0.7，max_tokens=8000
  · 支持中文 / 双语 / 英文三种提示词模板
    │
    ▼
题目文本（导入题库）
```

**独立数据库：** `ds_knowledge.db`（与 RAG 的 `kg.db` 完全隔离）

#### 两阶段流程

```
第一阶段：知识提取（一次性）
  上传文档 → 解析章节 → 逐章调用 DeepSeek(temp=0.3)
           → 输出结构化 JSON → 存入 ds_knowledge.db

第二阶段：题目生成（按需）
  用户筛选章节/知识点 → 从 ds_kps 读取 → 拼接知识图谱上下文
  → 调用 DeepSeek(temp=0.7) 出题 → 返回格式化题目文本
```

#### 数据库设计（ds_knowledge.db）

独立 SQLite 文件，不影响 RAG 的 `kg.db` 和主库 `exam_system.db`。

**三张表关系：**

```
ds_docs (1)
    │── (N) ds_chapters  ← 存储章节原始文本
    └── (N) ds_kps       ← 存储知识点与关系
```

**ds_docs — 文档元数据：**

| 字段 | 类型 | 说明 |
|-----|-----|-----|
| `doc_id` | TEXT PK | 文件名主干（截取 40 字符） |
| `filename` | TEXT | 原始文件名 |
| `subject` | TEXT | 学科名称 |
| `status` | TEXT | `uploaded` / `extracting` / `done` / `error` / `timeout` |
| `error_msg` | TEXT | 错误信息（空字符串表示正常） |
| `created_at` | TEXT | ISO 格式时间戳 |

**ds_chapters — 章节原文：**

| 字段 | 类型 | 说明 |
|-----|-----|-----|
| `id` | INTEGER PK | 自增主键 |
| `doc_id` | TEXT | 关联文档 |
| `chapter_num` | INTEGER | 章节序号（0 起） |
| `chapter_name` | TEXT | 章节标题 |
| `raw_text` | TEXT | 完整原文（**未截断**，最长不限） |

**ds_kps — 知识点：**

| 字段 | 类型 | 说明 |
|-----|-----|-----|
| `id` | INTEGER PK | 自增主键 |
| `doc_id` | TEXT | 关联文档 |
| `chapter_name` | TEXT | 所属章节名 |
| `chapter_num` | INTEGER | 所属章节号 |
| `kp_name` | TEXT | 知识点名称（5-20 字） |
| `kp_content` | TEXT | 知识点详细内容（200-500 字） |
| `relations_json` | TEXT | JSON 字符串，格式：`[{"type":"从属","target":"xxx"}]` |

#### 文档解析与章节分片

**各格式解析路径：**

| 文件格式 | 解析方式 | 是否异步 |
|---------|---------|---------|
| `.md` `.txt` | 直接读取文本 → `_parse_md_to_chapters()` | 同步 |
| `.docx` | python-docx 提取段落 → 按 Word Heading 样式转 `#`/`##` → `_parse_md_to_chapters()` | 同步 |
| `.pdf` | PaddleOCR API → `result.md` → `_parse_md_to_chapters()` | **异步**（后台线程） |
| `.pptx` `.ppt` | PaddleOCR API → `result.md` → `_parse_md_to_chapters()` | **异步**（后台线程） |

**章节分割正则：** 匹配以 `#` 或 `##` 开头（一级或二级标题），不匹配 `###` 及更深层标题（三级及以下视为正文）。

**章节文本截断：**
- **上限：** 8000 字符（约 2000~4000 tokens，视中英文比例）
- **截断策略：** 硬截断（非按句子/段落对齐），在末尾追加标注 `[（内容过长，已截断）]`

#### API 端点

| 方法 | 路径 | 说明 |
|------|------|------|
| `POST` | `/api/rag/ds-upload` | 上传文档并解析章节；`.pptx`/`.pdf` 异步 OCR，`.md`/`.txt`/`.docx` 同步 |
| `POST` | `/api/rag/ds-extract/<doc_id>` | 启动异步任务，逐章调用 DeepSeek 提取知识点（`temp=0.3`，每章最多 3000 tokens） |
| `GET` | `/api/rag/ds-tasks/<task_id>` | 轮询任务状态，返回 `{status, message, progress, total}` |
| `POST` | `/api/rag/ds-retry-ocr/<task_id>` | OCR 超时断点续传 |
| `GET` | `/api/rag/ds-docs` | 列出所有 DS 文档，含 `kp_count`、`chapter_count`、`status` |
| `GET` | `/api/rag/ds-docs/<doc_id>/kps` | 返回 `{chapters: [...], kps: [...]}` |
| `DELETE` | `/api/rag/ds-docs/<doc_id>` | 删除文档及其 ds_chapters / ds_kps 数据 |
| `POST` | `/api/rag/ds-generate` | 用筛选后的知识点拼 context → 调 DeepSeek 出题 |

#### OCR 复用机制与断点续传

DS 模式上传 PDF/PPTX 时，`_do_ocr_then_parse` 内联工作函数完全复用 `pptx_ocr.pipeline` 的已有逻辑：

```
upload PDF/PPTX
  ↓
process_pdf() / process_pptx()
  内部：split_pdf(chunk_size=10) → 逐批发 PaddleOCR API → 合并 result.md
  ↓
_parse_file_to_chapters(result_md, '.md')
  ↓
写入 ds_chapters（不写入 Qdrant/BM25）
```

与 RAG 模式的区别：RAG 模式 OCR 后调用 `ingestor.ingest_slides/textbook()` 写向量库；DS 模式只解析章节存文本，**不依赖 qdrant-client 和 sentence-transformers**。

**OCR 超时断点续传：**

PDF OCR 按每 10 页一块拆分，每块完成后立即持久化：

```
rag_uploads/<stem>_ocr/
    ├── checkpoint.json      ← {"total": 8, "done": [0, 1, 2, 3]}
    ├── _chunks/
    │   ├── chunk_0000.md    ← 第 1-10 页的 OCR markdown
    │   ├── chunk_0001.md    ← 第 11-20 页
    │   └── ...
    └── images/              ← 已下载的图片（实时写入）
```

超时后任务状态变为 `timeout`，前端显示重试按钮。重试时 `resume=True` 跳过已完成块，从断点继续。

#### 知识提取 API 参数与提示词设计

**提取阶段 API 调用参数：**

| 参数 | 值 | 设计意图 |
|-----|---|---------|
| `model` | `deepseek-chat` | DeepSeek 官方对话模型 |
| `temperature` | `0.3` | 极低温度，确保 JSON 格式稳定、知识点表述一致 |
| `max_tokens` | `3000` | 单章响应上限（3~8 个知识点，每个 200~500 字，足够） |
| `base_url` | `https://api.deepseek.com` | OpenAI 兼容接口 |

**提取提示词模板：**

```
请分析以下教材章节内容，提取该章节的核心知识点及其关系，构建知识图谱。

【学科/科目】：{subject}
【章节名称】：{chapter_name}

【章节原文】：
{chapter_text}

---
**任务要求：**
1. 提取 3-8 个核心知识点
2. 每个知识点的 content 字段应尽量引用原文关键表述，包含：定义/概念、特征/特点、分类/类型、示例/案例等
3. 仅标注同一章节内知识点之间的关系
4. 直接输出纯 JSON，不要添加代码块标记（```）或任何其他文字

**输出格式（严格遵守，直接输出 JSON）：**
{
  "chapter": "章节名称",
  "knowledge_points": [
    {
      "name": "知识点名称（5-20 字）",
      "content": "详细说明（引用原文，200-500 字，包含定义、特征、分类、示例）",
      "relations": [
        {"type": "从属", "target": "上位知识点名称"},
        {"type": "比较", "target": "对比知识点名称"},
        {"type": "并列", "target": "同级知识点名称"}
      ]
    }
  ]
}

关系类型（可组合使用，无关系则填 []）：从属、比较、并列、交叉、前提
```

**五种关系类型及含义：**

| 类型 | 语义 | 示例 |
|-----|-----|-----|
| `从属` | A 是 B 的下位概念 | 农作物 从属→ 植物 |
| `比较` | A 与 B 相对、对比 | 定性分析 比较→ 定量分析 |
| `并列` | A 与 B 同级平行 | 生产成本 并列→ 销售成本 |
| `交叉` | A 与 B 相互作用 | 土地质量 交叉→ 作物产量 |
| `前提` | A 的实现依赖 B | 播种 前提→ 土壤准备 |

#### 出题 API 参数与上下文组装

**出题阶段 API 调用参数：**

| 参数 | 提取阶段 | 出题阶段 | 差异原因 |
|-----|---------|---------|---------|
| `model` | `deepseek-chat` | `deepseek-chat` | 相同 |
| `temperature` | `0.3` | `0.7` | 出题需要一定多样性 |
| `max_tokens` | `3000` | `8000` | 出题内容更多 |
| System Role | 教材分析专家 | 教学内容设计专家 | 任务不同 |

**知识图谱上下文组装：**

前端支持三级联动筛选（文档 → 章节 → 知识点），未选择时拉取该文档的全部知识点。上下文按章节组织，格式示例：

```
## 第一章 农业经济学概论

### 知识点：农业经济学的研究对象
农业经济学是研究农业生产中经济关系和经济规律的科学……（200-500字）
关联关系：从属 → 经济学；比较 → 农业生产学

### 知识点：农业的基本特征
农业具有土地依附性、季节性、地域性等基本特征……
关联关系：并列 → 工业特征
```

**裁剪规则：**

| 层级 | 限制 | 说明 |
|-----|-----|-----|
| 单章文本（提取阶段） | 8000 字 | 输入给提取模型的原文上限 |
| 知识点上下文（生成阶段） | 7000 字 | 输入给出题模型的 context 上限 |
| 单知识点内容 | 200-500 字 | 提示词中的要求（非硬性强制） |

#### 错误处理与容错机制

**单章提取失败 — 跳过继续：**

逐章顺序调用时，单章失败不中断整体，记录跳过日志后继续下一章。覆盖场景：API 调用超时、JSON 解析失败、网络中断等。

**JSON 解析失败 — Markdown 代码块防御：**

```python
if raw.startswith('```'):
    raw = '\n'.join(raw.split('\n')[1:])   # 去掉首行（```json）
if raw.endswith('```'):
    raw = '\n'.join(raw.split('\n')[:-1])  # 去掉末行（```）
```

防御 DeepSeek 偶发的输出格式不规范（在 JSON 外包裹 Markdown 代码块）。若 JSON 解析仍失败，该章被跳过。

**API Key 未配置 — 提前返回：**

Key 读取优先级：`.env` 的 `DEEPSEEK_API_KEY` → `.env` 的 `DEEPSEEK_TOKEN` → 环境变量 `DEEPSEEK_API_KEY` → 环境变量 `DEEPSEEK_TOKEN`。

#### 前端模式切换

```javascript
let _aiMode = 'deepseek'; // 全局模式变量

setAiMode('rag')          // 先弹警告弹窗
closeRagWarning(true)     // 确认后 → _aiMode='rag' → _applyAiMode()

_applyAiMode()            // 切换两个左侧面板的 display
                          // 刷新文档列表（loadDsDocs 或 loadRagDocs）
                          // 调用 setRagPromptMode() 刷新提示词
```

`setRagPromptMode()` 感知 `_aiMode`，DS 模式下调用 `_adaptPromptForDs(prompt)` 对三句话做字符串替换，将"检索到的参考内容"改为"知识图谱信息"，避免维护两套 130+ 行的完整提示词模板。

`updateRagMeta()` 和 `ragGenerate()` 同样在函数入口检测 `_aiMode`，分别委托给 `dsUpdateMeta()` / `dsGenerate()`。

#### 参数速查表

**分片参数：**

| 参数 | 值 | 位置 |
|-----|---|-----|
| 章节触发正则 | `^#{1,2}\s+(.+)` | `rag_routes.py` |
| 识别标题级别 | `#` 和 `##`（一、二级） | - |
| 前置内容章节名 | `（前言/概述）` | - |
| 章节编号起始 | `0` | - |
| 空章节过滤 | `text.strip()` 为空则丢弃 | - |
| 章节文本截断 | 8000 字符 | - |
| PDF OCR 分块 | 每 10 页一块 | `pipeline.py` |
| PDF OCR 超时 | 120 秒/块（含 3 次重试） | `pptx_ocr/config.py` |

**知识提取 API 参数：**

| 参数 | 值 | 位置 |
|-----|---|-----|
| Model | `deepseek-chat` | `rag_routes.py` |
| Temperature | `0.3` | - |
| Max tokens | `3000` | - |
| Base URL | `https://api.deepseek.com` | - |
| 知识点数量要求 | 3~8 个/章 | 提示词 |
| 知识点名称长度 | 5~20 字 | 提示词 |
| 知识点内容长度 | 200~500 字 | 提示词 |

**出题 API 参数：**

| 参数 | 值 | 位置 |
|-----|---|-----|
| Model | `deepseek-chat` | `rag_routes.py` |
| Temperature | `0.7` | - |
| Max tokens | `8000` | - |
| 上下文字数上限 | 7000 字符 | - |
| 难度分布 | Easy 30% / Medium 50% / Hard 20% | 出题提示词 |
